{#Data type iteration target#}
{% set ts = meta['THETYPES'].values() %}
! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2019, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "src/Infrastructure/Base/interface/ESMF_Info.F90"
!==============================================================================

module ESMF_InfoMod

!==============================================================================
!
! This file contains the Fortran wrapper code for the C++ implementation of
!  the Info class.
!
!------------------------------------------------------------------------------

! INCLUDES
#include "ESMF.h"

!==============================================================================
!BOPI
! !MODULE: ESMF_InfoMod
!

!   Fortran API wrapper of C++ implemenation of Info
!
!------------------------------------------------------------------------------

! !USES:
use ESMF_UtilTypesMod     ! ESMF utility types
use ESMF_InitMacrosMod    ! ESMF initializer macros
use ESMF_BaseMod          ! ESMF base class
use ESMF_LogErrMod        ! ESMF error handling
use ESMF_VMMod
use iso_c_binding

implicit none

!private
!public :: ESMF_Info

!tdk:todo: need to specify public interfaces

include "ESMF_InfoCDef.F90"
include "ESMF_InfoCDefGeneric.F90"

type ESMF_Info
  type(C_PTR) :: ptr = C_NULL_PTR
end type ESMF_Info

interface ESMF_InfoCreate
  module procedure ESMF_InfoCreateEmpty
  module procedure ESMF_InfoCreateByKey
  module procedure ESMF_InfoCreateByParse
end interface ESMF_InfoCreate

interface ESMF_InfoGet
  module procedure ESMF_InfoGetI4
  module procedure ESMF_InfoGetI8
  module procedure ESMF_InfoGetR4
  module procedure ESMF_InfoGetR8
  module procedure ESMF_InfoGetLG
  module procedure ESMF_InfoGetCH
  module procedure ESMF_InfoGetArrayI4
  module procedure ESMF_InfoGetArrayI8
  module procedure ESMF_InfoGetArrayR4
  module procedure ESMF_InfoGetArrayR8
  module procedure ESMF_InfoGetArrayLG
  module procedure ESMF_InfoGetArrayCH
end interface ESMF_InfoGet

interface ESMF_InfoGetListAllocated
  module procedure ESMF_InfoGetArrayI4Allocated
  module procedure ESMF_InfoGetArrayI8Allocated
  module procedure ESMF_InfoGetArrayR4Allocated
  module procedure ESMF_InfoGetArrayR8Allocated
  module procedure ESMF_InfoGetArrayLGAllocated
  module procedure ESMF_InfoGetArrayCHAllocated
end interface ESMF_InfoGetListAllocated

interface ESMF_InfoSet
  module procedure ESMF_InfoSetI4
  module procedure ESMF_InfoSetI8
  module procedure ESMF_InfoSetR4
  module procedure ESMF_InfoSetR8
  module procedure ESMF_InfoSetLG
  module procedure ESMF_InfoSetCH
  module procedure ESMF_InfoSetINFO
  module procedure ESMF_InfoSetArrayI4
  module procedure ESMF_InfoSetArrayI8
  module procedure ESMF_InfoSetArrayR4
  module procedure ESMF_InfoSetArrayR8
  module procedure ESMF_InfoSetArrayLG
  module procedure ESMF_InfoSetArrayCH
end interface ESMF_InfoSet

interface operator(==)
  procedure ESMF_InfoEqual
end interface operator(==)
interface operator(/=)
  procedure ESMF_InfoNotEqual
end interface operator(/=)

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
character(*), parameter, private :: version = '$Id$'
!------------------------------------------------------------------------------

contains  !====================================================================

! =============================================================================
! Generic Methods =============================================================
! =============================================================================

!------------------------------------------------------------------------------
! Get (Scalar) ----------------------------------------------------------------
!------------------------------------------------------------------------------

{% for t in ts %}{% for do_charalloc in [False, True] %}
{% if t.ctype != "std::string" and do_charalloc%}
{#pass#}
{% else %}
{% set method_name = "ESMF_InfoGet"~t.esmf_suffix %}
{% if do_charalloc %}
{% set method_name = method_name~"Allocatable" %}
{% endif %}
#undef  ESMF_METHOD
#define ESMF_METHOD "{{ method_name }}()"
subroutine {{ method_name }}(info, key, value, default, idx, attnestflag, rc)
  type(ESMF_Info), intent(in) :: info
  character(len=*), intent(in) :: key
{% if t.ctype == "bool" %}
  {{ t.ftype }}, intent(inout) :: value
  {{ t.ftype }}, intent(in), optional :: default
{% elif t.ctype == "std::string" %}
  {% if do_charalloc %}
  {{ t.ftype }}(:), allocatable, intent(out) :: value
  {% else %}
  {{ t.ftype }}(len=*), intent(out) :: value
  {% endif %}
  {{ t.ftype }}(len=*), intent(in), optional :: default
{% else %}
  {{ t.ftype }}({{ t.esmf_type }}), intent(out) :: value
  {{ t.ftype }}({{ t.esmf_type }}), intent(in), optional :: default
{% endif %}
  integer, intent(in), optional :: idx
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc{%  if t.ctype == "std::string" %}, vlen{% endif %}{{ "" }}
{% if t.ctype == "std::string" %}
  {{ t.ftype }}(:), allocatable, target :: local_default
{% else %}
  {{ t.ftype }}({{ t.iso_ctype }}), target :: local_default
{% endif %}
{% if t.ctype == "bool" %}
  {{ t.ftype }}({{ t.iso_ctype }}) :: local_value
{% endif %}
  integer(C_INT), target :: local_idx
  type(C_PTR) :: local_default_ptr, local_idx_ptr
  integer(C_INT) :: recursive, strlen_only

  ! Set up local return code
  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE
  recursive = 0 !false
  strlen_only = 0 !false

  ! Handle optional arguments for C ###########################################

  if (present(default)) then
{% if t.ctype == "std::string" %}
    local_default = trim(default)//C_NULL_CHAR
{% else %}
    local_default = default
{% endif %}
    local_default_ptr = C_LOC(local_default)
  else
    local_default_ptr = C_NULL_PTR
  end if
  if (present(idx)) then
    local_idx = idx - 1  ! Shift to C (zero-based) indexing
    local_idx_ptr = C_LOC(local_idx)
  else
    local_idx_ptr = C_NULL_PTR
  end if
  if (present(attnestflag)) then
    if (attnestflag%value==ESMF_ATTNEST_ON%value) recursive = 1 !true
  end if

  ! Call C ####################################################################

{% if t.ctype != "std::string" %}
  call c_info_get_{{ t.esmf_suffix }}(&
    info%ptr, &
    trim(key)//C_NULL_CHAR, &
{% if t.ctype != "bool" %}
  {% set target = "value" %}
{% else %}
  {% set target = "local_value" %}
{% endif %}
    {{ target }}, &
    localrc, &
    local_default_ptr, &
    local_idx_ptr, &
    recursive)
{% else %}
  {% if do_charalloc %}
    strlen_only = 1 !true
    call c_info_get_CH(info%ptr, trim(key)//C_NULL_CHAR, value, vlen, &
      localrc, local_default_ptr, local_idx_ptr, recursive, strlen_only)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    strlen_only = 0 !false
    allocate(character(len=vlen) :: value)
  {% else %}
    vlen = LEN(value)
  {% endif %}
  call c_info_get_CH(info%ptr, trim(key)//C_NULL_CHAR, value, vlen, &
    localrc, local_default_ptr, local_idx_ptr, recursive, strlen_only)
{% endif %}
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

{% if t.ctype == "bool" %}
  value = local_value

{% endif %}
  if (present(rc)) rc = ESMF_SUCCESS
end subroutine {{ method_name }}

{% endif %}{% endfor %}{% endfor %}
!------------------------------------------------------------------------------
! GetArray --------------------------------------------------------------------
!------------------------------------------------------------------------------
{% for t in ts %}{% for alloc in [False, True] %}

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoGetArray{{ t.esmf_suffix }}{% if alloc %}Allocated{% endif %}()"
subroutine ESMF_InfoGetArray{{ t.esmf_suffix }}{% if alloc %}Allocated{% endif %}(info, key, values, itemcount, attnestflag, scalarToArray, rc)
  type(ESMF_Info), intent(in) :: info
  character(len=*), intent(in) :: key
  {{ t.full_ftype }}, dimension(:), {% if not alloc %} allocatable, {% endif %}intent(out) :: values
  integer, intent(out), optional :: itemcount
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(in), optional :: scalarToArray
  integer, intent(inout), optional :: rc

  integer :: localrc
  integer(C_INT) :: recursive, local_itemcount, local_scalarToArray_forC
{% if t.ctype == "bool" or t.ctype == "std::string"%}
  integer :: ii
{% endif %}
{% if t.ctype == "std::string" %}
  logical :: is_array
{% endif %}
{% if t.ctype == "bool" %}
  {{ t.ftype }}({{ t.iso_ctype }}), dimension(:), allocatable :: local_values
{% endif %}
  logical :: local_scalarToArray

  local_scalarToArray = .false.
  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE
  recursive = 0 !false
  if (present(scalarToArray)) then
    local_scalarToArray = scalarToArray
  end if

  if (present(attnestflag)) then
    if (attnestflag%value==ESMF_ATTNEST_ON%value) recursive = 1 !true
  end if

  if (local_scalarToArray) then
    local_scalarToArray_forC = 1 !true
  else
    local_scalarToArray_forC = 0 !false
  end if

  ! Get the array size from the info store
  call ESMF_InfoInquire(info, key=key, size=local_itemcount, attnestflag=attnestflag, &
{% if t.ctype == "std::string" %}
    isArray=is_array, &
{% endif %}
    rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
{% if t.ctype == "std::string" %}

  if (.not. is_array .and. .not. local_scalarToArray) then
    if (ESMF_LogFoundError(ESMF_RC_ATTR_WRONGTYPE, &
      msg="Array requested but type in JSON storage is not an array. Key is: "//TRIM(key), &
      ESMF_CONTEXT, rcToReturn=rc)) return
  end if
{% endif %}
{% if alloc %}

  if (local_itemcount /= SIZE(values)) then
    if (ESMF_LogFoundError(ESMF_RC_ATTR_ITEMSOFF, msg="values allocation size does not match size in Info storage", ESMF_CONTEXT, rcToReturn=rc)) return
  end if
{% endif %}

  ! Allocate the outgoing storage array and call into C to fill the array
{% if not alloc %}
  allocate(values(local_itemcount))
{% endif %}
{% if t.ctype == "bool" %}
  allocate(local_values(local_itemcount))
{% endif %}
{% if t.ctype != "std::string" %}
  call c_info_get_array_{{ t.esmf_suffix }}(&
    info%ptr, &
    trim(key)//C_NULL_CHAR, &
{% if t.ctype != "bool" %}
  {% set target = "values" %}
{% else %}
  {% set target = "local_values" %}
{% endif %}
    {{ target }}, &
    local_itemcount, &
    localrc, &
    recursive, &
    local_scalarToArray_forC)
{% else %}
  do ii=1,local_itemcount
    if (.not. is_array .and. local_scalarToArray) then
      call ESMF_InfoGetCH(info, key, values(ii), attnestflag=attnestflag, rc=localrc)
    else
      call ESMF_InfoGetCH(info, key, values(ii), idx=ii, attnestflag=attnestflag, rc=localrc)
    end if
  enddo
{% endif %}
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

{% if t.ctype == "bool" %}
  do ii=1,SIZE(values)
    values(ii) = local_values(ii)
  enddo
  deallocate(local_values)

{% endif %}
  if (present(itemcount)) itemcount = local_itemcount
  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoGetArray{{ t.esmf_suffix }}{% if alloc %}Allocated{% endif %}

{% endfor %}{% endfor %}

!------------------------------------------------------------------------------
! Set (Scalar) ----------------------------------------------------------------
!------------------------------------------------------------------------------
{% for t in ts %}

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoSet{{ t.esmf_suffix }}()"
subroutine ESMF_InfoSet{{ t.esmf_suffix }}(info, key, value, force, idx, pkey, rc)
  type(ESMF_Info), intent(inout) :: info
  character(len=*), intent(in) :: key
{% if t.ctype == "std::string" %}
  character(len=*), intent(in) :: value
{% elif t.ctype == "bool" %}
  {{ t.ftype }}, intent(in) :: value
{% else %}
  {{ t.ftype }}({{ t.esmf_type }}), intent(in) :: value
{% endif %}
  logical, intent(in), optional :: force
  integer, intent(in), optional :: idx
  character(len=*), intent(in), optional :: pkey
  integer, intent(inout), optional :: rc

  integer :: localrc
  logical(C_BOOL) :: local_force{% if t.ctype == "bool" %}, local_value{% endif %}{{ "" }}
  integer(C_INT), target :: local_idx
  type(C_PTR) :: local_idx_ptr
  character(:), allocatable :: local_pkey

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  if (present(force)) then
    local_force = force
  else
    local_force = .true.
  end if
  if (present(idx)) then
    local_idx = idx - 1  ! Shift to C (zero-based) indexing
    local_idx_ptr = C_LOC(local_idx)
  else
    local_idx_ptr = C_NULL_PTR
  end if
  if (present(pkey)) then
    local_pkey = TRIM(pkey)//C_NULL_CHAR
  else
    local_pkey = ""//C_NULL_CHAR
  end if

{% if t.ctype == "bool" %}
  local_value = value
{% endif %}
  call c_info_set_{{ t.esmf_suffix }}(&
    info%ptr, &
    trim(key)//C_NULL_CHAR, &
{% if t.ctype == "std::string" %}
  {% set target = "trim(value)//C_NULL_CHAR" %}
{% elif t.ctype == "bool" %}
  {% set target = "local_value" %}
{% else %}
  {% set target = "value" %}
{% endif %}
    {{ target }}, &
    local_force, &
    localrc, &
    local_idx_ptr, &
    local_pkey)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoSet{{ t.esmf_suffix }}
{% endfor %}

!------------------------------------------------------------------------------
! SetArray --------------------------------------------------------------------
!------------------------------------------------------------------------------
{% for t in ts %}
{% if t.ctype == "std::string" %}{% set is_str = True %}{% else %}{% set is_str = False %}{% endif %}

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoSetArray{{ t.esmf_suffix }}()"
subroutine ESMF_InfoSetArray{{ t.esmf_suffix }}(info, key, values, force, pkey, rc)
  type(ESMF_Info), intent(inout) :: info
  character(len=*), intent(in) :: key
{% if is_str %}
  character(len=*), dimension(:), intent(in) :: values
{% else %}
  {{ t.ftype }}{% if t.ctype != "bool" %}({{ t.esmf_type }}){% endif %}, dimension(:), intent(in) :: values
{% endif %}
  logical, intent(in), optional :: force
  character(len=*), intent(in), optional :: pkey
  integer, intent(inout), optional :: rc

  integer :: localrc
  logical(C_BOOL) :: local_force
{% if t.ctype == "bool" %}
  integer :: ii
  logical(C_BOOL), dimension(:), allocatable :: local_values
{% elif is_str %}
  integer :: ii
  integer(C_INT) :: idx
{% endif %}
  character(:), allocatable :: local_pkey
  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  if (present(force)) then
    local_force = force
  else
    local_force = .true.
  end if
  if (present(pkey)) then
    local_pkey = TRIM(pkey)//C_NULL_CHAR
  else
    local_pkey = ""//C_NULL_CHAR
  end if
{% if t.ctype == "bool" %}

  allocate(local_values(SIZE(values)))
  do ii=1,SIZE(values)
    local_values(ii) = values(ii)
  enddo
{% endif %}

  ! Call into C ----------------------------------------------------------------

{% if is_str %}
  ! Allocate storage in C
  call c_info_set_array_CH(info%ptr, trim(key)//C_NULL_CHAR, &
    SIZE(values), local_force, localrc, local_pkey)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  ! Set each character element in the underlying store
  do ii=1,SIZE(values)
    call ESMF_InfoSetCH(info, key, values(ii), idx=ii, pkey=local_pkey, rc=localrc)
  enddo
{% else %}
  call c_info_set_array_{{ t.esmf_suffix }}(&
    info%ptr, &
    trim(key)//C_NULL_CHAR, &
{% if t.ctype == "bool" %}
  {% set target = "local_values" %}
{% else %}
  {% set target = "values" %}
{% endif %}
    {{ target }}, &
    SIZE(values), &
    local_force, &
    localrc, &
    local_pkey)
{% endif %}
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

{% if t.ctype == "bool" %}
  deallocate(local_values)

{% endif %}
  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoSetArray{{ t.esmf_suffix }}
{% endfor %}

! =============================================================================
! Non-Generic Methods =========================================================
! =============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoBaseGet()"
function ESMF_InfoBaseGet(base) result(info)
  type(ESMF_Base), intent(in) :: base
  type(ESMF_Info) :: info
  info%ptr = c_info_base_get(base%this%ptr)
end function ESMF_InfoBaseGet

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoPointerGet()"
function ESMF_InfoPointerGet(ptr) result(info)
  type(ESMF_Pointer), intent(in) :: ptr
  type(ESMF_Info) :: info
  info%ptr = c_info_base_get(ptr%ptr)
end function ESMF_InfoPointerGet

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoCopy()"
function ESMF_InfoCopy(info, rc) result(info_copy)
  type(ESMF_Info), intent(in) :: info
  integer, intent(inout), optional :: rc
  type(ESMF_Info) :: info_copy

  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  info_copy%ptr = c_info_copy(info%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
                         rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoCopy

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoCreateEmpty()"
function ESMF_InfoCreateEmpty(rc) result(info)
  integer, intent(inout), optional :: rc
  integer :: localrc
  type(ESMF_Info) :: info

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  info%ptr = c_info_create(localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
                         rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoCreateEmpty

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoCreateByKey()"
function ESMF_InfoCreateByKey(srcInfo, key, rc) result(info)
  type(ESMF_Info), intent(in) :: srcInfo
  character(len=*), intent(in) :: key
  integer, intent(inout), optional :: rc
  type(ESMF_Info) :: info

  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  info%ptr = c_info_create_by_key(srcInfo%ptr, trim(key)//C_NULL_CHAR, &
    localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoCreateByKey

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoCreateByParse()"
function ESMF_InfoCreateByParse(payload, rc) result(info)
  character(len=*), intent(in) :: payload
  integer, intent(inout), optional :: rc
  type(ESMF_Info) :: info

  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  info%ptr = c_info_create_by_parse(trim(payload)//C_NULL_CHAR, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoCreateByParse

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoBroadcast()"
subroutine ESMF_InfoBroadcast(info, rootPet, rc)
  type(ESMF_Info), intent(inout) :: info
  integer, intent(in) :: rootPet
  integer, intent(inout), optional :: rc
  integer :: localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_FAILURE

  call c_info_broadcast(info%ptr, rootPet, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
                         rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoBroadcast

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoDestroy()"
subroutine ESMF_InfoDestroy(info, rc)
  type(ESMF_Info), intent(inout) :: info
  integer, intent(inout), optional :: rc
  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  call c_info_destroy(info%ptr, localrc)
  info%ptr = C_NULL_PTR
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
                         rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoDestroy

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoDump()"
function ESMF_InfoDump(info, key, rc) result(output)
  type(ESMF_Info), intent(in) :: info
  character(*), intent(in), optional :: key
  integer, intent(inout), optional :: rc
  character(:), allocatable :: output

  character(:), allocatable :: l_key
  integer :: dump_length, localrc

  localrc = ESMF_RC_NOT_IMPL
  if (present(rc)) rc = ESMF_RC_NOT_IMPL

  if (present(key)) then
    l_key = key
  else
    l_key = ""
  endif

  call c_info_dump_len(info%ptr, dump_length, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT)) return

  allocate(character(dump_length)::output)

  call c_info_dump(info%ptr, output, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT)) return

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoDump

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoEqual()"
function ESMF_InfoEqual(lhs, rhs) result(is_equal)
  type(ESMF_Info), intent(in) :: lhs
  type(ESMF_Info), intent(in) :: rhs
  logical :: is_equal

  integer :: localrc
  logical(C_BOOL) :: local_is_equal

  is_equal = .false.
  call c_info_is_equal(lhs%ptr, rhs%ptr, local_is_equal, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT)) return

  is_equal = local_is_equal
end function ESMF_InfoEqual

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoNotEqual()"
function ESMF_InfoNotEqual(lhs, rhs) result(is_equal)
  type(ESMF_Info), intent(in) :: lhs
  type(ESMF_Info), intent(in) :: rhs
  logical :: is_equal
  is_equal = .not. ESMF_InfoEqual(lhs, rhs)
end function ESMF_InfoNotEqual

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoRemove()"
subroutine ESMF_InfoRemove(info, keyParent, keyChild, attnestflag, rc)
  type(ESMF_Info), intent(inout) :: info
  character(len=*), intent(in) :: keyParent
  character(len=*), intent(in), optional :: keyChild
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc
  character(:), allocatable :: localkeyChild
  logical(C_BOOL) :: recursive

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE
  recursive = .false.

  if (present(keyChild)) then
    localkeyChild = keyChild
  else
    localkeyChild = ""
  end if
  if (present(attnestflag)) then
    if (attnestflag%value==ESMF_ATTNEST_ON%value) recursive = .true.
  end if

  call c_info_erase(info%ptr, trim(keyParent)//C_NULL_CHAR, &
                     trim(localkeyChild)//C_NULL_CHAR, recursive, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
                         rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoRemove

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoInquire()"
subroutine ESMF_InfoInquire(info, key, size, attrCount, attrCountTotal, jsonType, &
  isArray, isDirty, attPackCount, attPackCountTotal, attnestflag, idx, typekind, &
  ikey, isPresent, isStructured, isNull, attrCompliance, rc)

  type(ESMF_Info), intent(in) :: info
  character(len=*), intent(in), optional :: key
  integer(C_INT), intent(out), optional :: size
  integer(C_INT), intent(out), optional :: attrCount
  integer(C_INT), intent(out), optional :: attrCountTotal
  character(len=*), intent(out), optional :: jsonType
  logical, intent(out), optional :: isArray
  logical, intent(out), optional :: isDirty
  integer(C_INT), intent(out), optional :: attPackCount
  integer(C_INT), intent(out), optional :: attPackCountTotal
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer(C_INT), intent(in), optional :: idx
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  character(len=*), intent(out), optional :: ikey
  logical, intent(out), optional :: isPresent
  logical, intent(out), optional :: isStructured
  logical, intent(out), optional :: isNull
  logical, intent(in), optional :: attrCompliance
  integer, intent(inout), optional :: rc

  integer :: localrc, esmc_typekind, local_size
  type(ESMF_Info) :: inq, inq2
  character(:), allocatable :: local_key
  integer :: recursive, local_attrCompliance
  integer(C_INT), target :: local_idx
  type(C_PTR) :: local_idx_ptr

  if (present(rc)) rc = ESMF_FAILURE
  localrc = ESMF_FAILURE
  recursive = 0 !false
  local_attrCompliance = 0 !false

  if (present(key)) then
    local_key = trim(key)
  else
    local_key = ""
  end if
  if (present(attnestflag)) then
    if (attnestflag%value==ESMF_ATTNEST_ON%value) recursive = 1 !true
  end if
  if (present(idx)) then
    local_idx = idx - 1  ! Shift to C (zero-based) indexing
    local_idx_ptr = C_LOC(local_idx)
  else
    local_idx_ptr = C_NULL_PTR
  end if
  if (present(attrCompliance)) then
    if (attrCompliance) local_attrCompliance = 1 !true
  end if

  if (present(isPresent)) then
    if (LEN(key) > 0) then
      isPresent = ESMF_InfoIsPresent(info, local_key, isPointer=.true., &
        attnestflag=attnestflag, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    else
      isPresent = .true.
    end if
  end if

  inq = ESMF_InfoCreate(rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_inquire(info%ptr, inq%ptr, local_key//C_NULL_CHAR, recursive, &
   local_idx_ptr, local_attrCompliance, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(size)) then
      call ESMF_InfoGet(inq, "size", size, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(attrCount)) then
    call ESMF_InfoGet(inq, "attrCount", attrCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(attrCountTotal)) then
      call ESMF_InfoGet(inq, "attrCountTotal", attrCountTotal, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(jsonType)) then
    call ESMF_InfoGet(inq, "jsonType", jsonType, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(isArray)) then
    call ESMF_InfoGet(inq, "isArray", isArray, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(isDirty)) then
    call ESMF_InfoGet(inq, "isDirty", isDirty, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(attPackCount)) then
    call ESMF_InfoGet(inq, "attPackCount", attPackCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(attPackCountTotal)) then
      call ESMF_InfoGet(inq, "attPackCountTotal", attPackCountTotal, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(typekind)) then
    call ESMF_InfoGet(inq, "ESMC_TypeKind_Flag", esmc_typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    typekind = ESMF_TypeKind_Flag(esmc_typekind)
  end if
  if (present(ikey)) then
    call ESMF_InfoGet(inq, "key", ikey, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(idx)) then
    if (present(isPresent)) then
      if (isPresent) then
          inq2 = ESMF_InfoCreate(rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

          call c_info_inquire(info%ptr, inq2%ptr, local_key//C_NULL_CHAR, recursive, &
            C_NULL_PTR, local_attrCompliance, localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

          call ESMF_InfoGet(inq2, "size", local_size, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

          if (idx > local_size) then
            isPresent = .false.
          end if

          call ESMF_InfoDestroy(inq2, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
       end if
    end if
  end if
  if (present(isStructured)) then
    call ESMF_InfoGet(inq, "isStructured", isStructured, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if
  if (present(isNull)) then
    call ESMF_InfoGet(inq, "isNull", isNull, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  call ESMF_InfoDestroy(inq, rc=rc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoInquire

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoIsPresent()"
function ESMF_InfoIsPresent(info, key, attnestflag, isPointer, rc) result(is_present)
  type(ESMF_Info), intent(in) :: info
  character(len=*), intent(in) :: key
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(in), optional :: isPointer
  integer, intent(inout), optional :: rc
  logical :: is_present

  logical :: local_isPointer
  integer :: localrc
  integer(C_INT) :: isPointer_forC
  integer(C_INT) :: local_is_present
  integer(C_INT) :: recursive

  is_present = .false.
  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE
  recursive = 0 !false
  local_is_present = 0 !false

  if (present(attnestflag)) then
    if (attnestflag%value==ESMF_ATTNEST_ON%value) recursive = 1 !true
  end if
  if (present(isPointer)) then
    local_isPointer = isPointer
  else
    local_isPointer = .false.
  end if

  if (local_isPointer) then
    isPointer_forC = 1 !true
  else
    isPointer_forC = 0 !false
  end if

  call c_info_is_present(info%ptr, trim(key)//C_NULL_CHAR, local_is_present, &
    localrc, recursive, isPointer_forC)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  if (local_is_present == 1) then
    is_present = .true.
  else
    is_present = .false.
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoIsPresent

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoIsSet()"
function ESMF_InfoIsSet(info, key, rc) result(is_set)
  type(ESMF_Info), intent(in) :: info
  character(len=*), intent(in) :: key
  integer, intent(inout), optional :: rc
  logical :: is_set

  integer :: localrc
  integer(C_INT) :: is_set_c

  is_set = .false.
  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  call c_info_is_set(info%ptr, trim(key)//C_NULL_CHAR, is_set_c, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  if (is_set_c == 1) then
    is_set = .true.
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoIsSet

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoPrint()"
subroutine ESMF_InfoPrint(info, indent, rc)
  type(ESMF_Info), intent(in) :: info
  integer, intent(in), optional :: indent
  integer, intent(inout), optional :: rc

  integer :: localrc, localindent

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  if (present(indent)) then
    localindent = indent
  else
    localindent = 4
  end if

  call c_info_print(info%ptr, localindent, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
      rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoPrint

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoUpdate()"
subroutine ESMF_InfoUpdate(lhs, rhs, rc)
  type(ESMF_Info), intent(inout) :: lhs
  type(ESMF_Info), intent(in) :: rhs
  integer, intent(inout), optional :: rc

  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  call c_info_update(lhs%ptr, rhs%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
      rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoUpdate

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoReadJSON()"
function ESMF_InfoReadJSON(filename, rc) result(info_r)
  character(len=*), intent(in) :: filename
  integer, intent(inout), optional :: rc
  type(ESMF_Info) :: info_r

  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  info_r = ESMF_InfoCreate(rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  call c_info_read_json(info_r%ptr, trim(filename)//C_NULL_CHAR, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end function ESMF_InfoReadJSON

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoWriteJSON()"
subroutine ESMF_InfoWriteJSON(info, filename, rc)
  type(ESMF_Info), intent(in) :: info
  character(len=*), intent(in) :: filename
  integer, intent(inout), optional :: rc

  integer :: localrc

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  call c_info_write_json(info%ptr, trim(filename)//C_NULL_CHAR, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
      rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoWriteJSON

!------------------------------------------------------------------------------

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoSetNULL()"
subroutine ESMF_InfoSetNULL(info, key, force, rc)
  type(ESMF_Info), intent(inout) :: info
  character(len=*), intent(in) :: key
  logical, intent(in), optional :: force
  integer, intent(inout), optional :: rc

  integer :: localrc
  logical(C_BOOL) :: local_force

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  if (present(force)) then
    local_force = force
  else
    local_force = .true.
  end if

  call c_info_set_NULL(info%ptr, trim(key)//C_NULL_CHAR, local_force, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoSetNULL

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InfoSetINFO()"
subroutine ESMF_InfoSetINFO(info, key, value, force, rc)
  type(ESMF_Info), intent(inout) :: info
  character(len=*), intent(in) :: key
  type(ESMF_Info), intent(in) :: value
  logical, intent(in), optional :: force
  integer, intent(inout), optional :: rc

  integer :: localrc
  logical(C_BOOL) :: local_force

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_FAILURE

  if (present(force)) then
    local_force = force
  else
    local_force = .true.
  end if

  call c_info_set_INFO(&
    info%ptr, &
    trim(key)//C_NULL_CHAR, &
    value%ptr, &
    local_force, &
    localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, &
    rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_InfoSetINFO

end module ESMF_InfoMod  !===============================================
