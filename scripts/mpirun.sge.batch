#!/bin/ksh 
# $Id: mpirun.sge.batch,v 1.4.4.2 2008/01/29 19:49:09 svasquez Exp $
# This script provides an interface such that the simple command
# mpirun -np #
# runs # copies of the program in parallel.

if [ "$1" != "-np" ]
then
        echo "Usage: mpirun -np #"
        exit 1
fi

export np=$2
shift 2
export prog=$*

export working_dir=`pwd`


# Extract batch run script
cat > $ESMF_DIR/scripts/esmf_script << THE_END_OF_BATCH_SCRIPT
#!/bin/csh -f
#
#  Set the name of the job.
#$ -N esmf_test
#
#  Make sure that the .e and .o file arrive in the working directory
#$ -cwd
#
#$ $ESMF_BATCHOPTIONS
#
#  My code is re-runnable
#$ -r n
#
#  The max walltime for this job is 30 minutes
#$ -l h_rt=00:30:00


#source /usr/local/bin/setup-mpi.csh

cd $working_dir

mpirun -np $np  $prog


THE_END_OF_BATCH_SCRIPT

#chmod a+x $ESMF_DIR/scripts/esmf_script

echo " qsub  $ESMF_DIR/scripts/esmf_script"

job_num=`qsub  $ESMF_DIR/scripts/esmf_script `

# Since this is not an interactive shell, we must grep for the proc_id until 
# it is gone, indicating the job is done or the walltime has expired.

# Strip off name and keep the number for grepping.
echo $job_num > proc_id_file
read word1 word2 proc_id word4 < proc_id_file
echo $proc_id > proc_id

while qstat | grep $proc_id > tmp
do
	# if the test can't be run delete it.
	if grep Eqw tmp
	then
		qdel $proc_id
	else
        	sleep 30
	fi
done

# move job output file to stdout.
mv -f esmf_test.o$proc_id  $prog.stdout


# Clean up
rm -f esmf_script
rm -f proc_id_file
rm -f tmp
