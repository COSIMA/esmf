// $Id$
/*
 * Writes trace events to the file system.
 *
 * Earth System Modeling Framework
 * Copyright 2002-2018, University Corporation for Atmospheric Research, 
 * Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
 * Laboratory, University of Michigan, National Centers for Environmental 
 * Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
 * NASA Goddard Space Flight Center.
 * Licensed under the University of Illinois-NCSA License.
 */

#include <iomanip>
#include <sstream>
#include <string>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/stat.h>

#ifndef ESMF_OS_MinGW
#include <unistd.h>
#else
#include <Winsock.h>
#endif

#ifndef ESMF_NO_DLFCN
#include <dlfcn.h>
#endif

#include "ESMCI_Macros.h"
#include "ESMCI_Util.h"
#include "ESMCI_LogErr.h"
#include "ESMCI_VM.h"
#include "ESMCI_Trace.h"
#include "ESMCI_Comp.h"
#include "ESMCI_VMKernel.h"
#include "ESMCI_HashMap.h"
#include "ESMCI_RegionNode.h"
#include "ESMCI_ComponentInfo.h"
#include "ESMCI_TraceUtil.h"
#include <esmftrc.h>

#ifndef ESMF_OS_MinGW
#define TRACE_DIR_PERMISSIONS (S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH)
#else
#define TRACE_DIR_PERMISSIONS (S_IRWXU)
#endif

#define EVENT_BUF_SIZE_DEFAULT 4096
#define EVENT_BUF_SIZE_EAGER 1024
#define REGION_HASHTABLE_SIZE 100
#define VMID_MAP_SIZE 10000

using std::string;
using std::vector;
using std::stringstream;
using std::ofstream;

namespace ESMCI {

  struct StringHashF {
    unsigned long operator()(const string& s) const {
      unsigned long hash = 5381;
      int c;
      const char *str = s.c_str();     
      while ((c = *str++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
      //printf("hash for %s = %d\n", s.c_str(), hash % REGION_HASHTABLE_SIZE);
      return hash % REGION_HASHTABLE_SIZE;
    }
  };

  struct ESMFPhaseHashF {
    unsigned long operator()(const ESMFPhaseId& phaseId) const {
      return phaseId.hashcode() % REGION_HASHTABLE_SIZE;
    }
  };

  struct ESMFIdHashF {
    unsigned long operator()(const ESMFId& esmfId) const {
      return esmfId.hashcode() % REGION_HASHTABLE_SIZE;
    }
  };

  static bool traceInitialized = false;  // is trace ready for events?
  static bool traceLocalPet = false;     // is tracing on for this PET?
  static bool profileLocalPet = false;   // is profiling on for this PET?
  static bool profileOutputToLog = false;    // output to EMSF log?
  static bool profileOutputToFile = false;   // output to text file?
  static bool profileOutputToBinary = false; // output to binary trace?
  
  /*
    Timed regions are defined by either:
     1) a component phase represented by (vmid, baseid, method, phase), or
     2) a user-defined region name (from ESMF_TraceRegionEnter()/Exit() calls)

    Both are mapped to a single integer id for the region.  In the trace
    we output a "definition" event for each region, which includes the
    region id and either the user-defined name or the (vmid, baseid, method, phase)
    tuple.  The trace post-processor can then translate the ids back to
    meaningful names.  Using only integer ids reduces the size of the trace files.

    userRegionMap:  maps from user-defined name to region id
    phaseRegionMap:  maps from phase (vmid,baseid,method,phase) to region id
    
    componentInfoMap:  maps from (vmid,baseid) to an object
                       for keeping track of component information

   */

  static HashMap<string, int, REGION_HASHTABLE_SIZE, StringHashF> userRegionMap;
  static HashMap<ESMFPhaseId, int, REGION_HASHTABLE_SIZE, ESMFPhaseHashF> phaseRegionMap;
  static HashMap<ESMFId, ComponentInfo *, REGION_HASHTABLE_SIZE, ESMFIdHashF> componentInfoMap;

  static RegionNode rootRegionNode;
  static RegionNode *currentRegionNode = &rootRegionNode;
  
#ifndef ESMF_NO_DLFCN
  static int (*notify_wrappers)(int initialized) = NULL;
#endif

#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceMapVmId()"  
  int TraceMapVmId(VMId *vmid, int *rc) {

    //this data structure used to map VMIds(vmKey,localid)
    //to an integer id
    static VMId vmIdMap[VMID_MAP_SIZE];
    static int nextVmId = 0;

    int localrc = ESMC_RC_NOT_IMPL;
    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;
    
    int foundIdx;
    //search backward - vm more likely to be at the end
    for (foundIdx=nextVmId-1; foundIdx >= 0; foundIdx--) {
      if (VMIdCompare(vmid, &(vmIdMap[foundIdx]))) {
        if (rc!=NULL) *rc = ESMF_SUCCESS;
        return foundIdx;
      }
    }
    if (nextVmId >= VMID_MAP_SIZE) {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,
                                    "Out of VmIdMap space inside tracing", ESMC_CONTEXT, rc);
      return -1;
    }
    else {
      localrc = (&vmIdMap[nextVmId])->create();
      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,
                                        ESMC_CONTEXT, rc))
        return -1;
      VMIdCopy(&(vmIdMap[nextVmId]), vmid);
      foundIdx = nextVmId;
      nextVmId++;
      
      if (rc!=NULL) *rc=ESMF_SUCCESS;
      return foundIdx;
    } 
  }
  
  bool TraceInitialized() {
    return traceInitialized;
  }


#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::CheckPETList"
  static bool CheckPETList(string petList, int petToCheck, int *rc) {
    if (rc!=NULL) *rc = ESMF_SUCCESS;
    
    bool invalidFormat = false;
    const vector<string> listItems = split(trim(petList), " ");
    
    for (unsigned i = 0; i < listItems.size(); i++) {
      if (listItems.at(i).find("-") != string::npos) {	  
        vector<string> petRange = split(trim(listItems.at(i)), "-");
        if (petRange.size() == 2) {
          int low, high;
          stringstream lowss(trim(petRange.at(0)));
          stringstream highss(trim(petRange.at(1)));
          if (!(lowss >> low).fail() && !(highss >> high).fail()) {
            //printf("low=%d, high=%d\n", low, high);
            if (petToCheck >= low && petToCheck <= high) {
              return true;
            }
          }
          else {
            invalidFormat = true;
          }
        }
        else {
          invalidFormat = true;
        }
      }
      else {  
        int pet = -1;
        stringstream ss(trim(listItems.at(i)));
        ss >> pet;	  
        if(!(ss.fail())) {
          if (petToCheck == pet) {
            return true;
          }
        }	
        else {
          invalidFormat = true;
        }	  
      }
      if (invalidFormat) {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,
                                      "Invalid PET list format.", 
                                      ESMC_CONTEXT, rc);
        return false;
      }
      
    }
    
    //pet not found in list      
    return false;  
}
  
#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::ProfileIsEnabledForPET()"
  static bool ProfileIsEnabledForPET(int petToCheck, int *rc) {
    int localrc;
    if (rc != NULL) *rc = ESMF_SUCCESS;

    int tracingEnabled = 0;
    int profilingEnabled = 0;
    localrc = Comp::getComplianceCheckerTrace(&tracingEnabled, &profilingEnabled);
    if (ESMC_LogDefault.MsgFoundError(localrc, 
         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) 
      return false;

    if (profilingEnabled == 0) return false;

    //always profile PET 0?
    if (petToCheck == 0) return true;
    
    char const *envVar = VM::getenv("ESMF_RUNTIME_PROFILE_PETLIST");
    if (envVar != NULL) {     
      string envStr(envVar);
      bool inPetList = CheckPETList(envStr, petToCheck, &localrc);
      if (ESMC_LogDefault.MsgFoundError(localrc, 
           "Invalid format in ESMF_RUNTIME_PROFILE_PETLIST environment variable.", ESMC_CONTEXT, rc)) 
        return false;
      return inPetList;
    }
    else {
      //default to profile all PETs
      return true;
    }
  }
     
#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceIsEnabledForPET()"  
  static bool TraceIsEnabledForPET(int petToCheck, int *rc){ 
    int localrc;
    if (rc != NULL) *rc = ESMF_SUCCESS;
    
    //first check if tracing is enabled
    int tracingEnabled = 0;
    int profilingEnabled = 0;
    localrc = Comp::getComplianceCheckerTrace(&tracingEnabled, &profilingEnabled);
    if (ESMC_LogDefault.MsgFoundError(localrc, 
         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) 
      return false;

    if (tracingEnabled == 0) return false;
    
    //always trace PET 0
    if (petToCheck == 0) return true;
    
    char const *envVar = VM::getenv("ESMF_RUNTIME_TRACE_PETLIST");
    if (envVar != NULL) {     
      string envStr(envVar);
      bool inPetList = CheckPETList(envStr, petToCheck, &localrc);
      if (ESMC_LogDefault.MsgFoundError(localrc, 
           "Invalid format in ESMF_RUNTIME_TRACE_PETLIST environment variable.", ESMC_CONTEXT, rc)) 
        return false;
      return inPetList;
    }
    else {
      //default to trace all PETs
      return true;
    }
    
  }
  
  //global context
  static struct esmftrc_platform_filesys_ctx *traceCtx = NULL;

  static struct esmftrc_default_ctx *esmftrc_platform_get_default_ctx() {
    return &traceCtx->ctx;
  }
  
  static void write_packet(struct esmftrc_platform_filesys_ctx *ctx) {
    size_t nmemb = fwrite(esmftrc_packet_buf(&ctx->ctx),
			  esmftrc_packet_buf_size(&ctx->ctx), 1, ctx->fh);
    assert(nmemb == 1);
  }

  static int is_backend_full(void *data) {
    //assume file system never full
    return 0;
  }

  static void open_packet(void *data) {
    struct esmftrc_platform_filesys_ctx *ctx =
      FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, data);
    
    esmftrc_default_open_packet(&ctx->ctx, ctx->nodename, ctx->stream_id);
  }

  static void close_packet(void *data) {
    struct esmftrc_platform_filesys_ctx *ctx =
      FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, data);
    
    // close packet now
    esmftrc_default_close_packet(&ctx->ctx);
    
    // write packet to file 
    write_packet(ctx);
  }

#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::write_metadata()"  
  static void write_metadata(const char *trace_dir, int *rc) {

    if (rc!=NULL) *rc = ESMF_SUCCESS;
    
    string metadata_string = TraceGetMetadataString();
    string filename(trace_dir);
    filename += "/metadata";
    
    std::ofstream ofs (filename.c_str(), std::ofstream::trunc);
    if (ofs.is_open() && !ofs.fail()) {
      ofs << metadata_string;
      ofs.close();
    }
    else {
      ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, "Error writing trace metadata file", 
                                    ESMC_CONTEXT, rc);
    }
  }

#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::InitializeWrappers()"
  static void InitializeWrappers() {
    int wrappersPresent = TRACE_WRAP_NONE;
#ifndef ESMF_NO_DLFCN
    void *preload_lib = dlopen(NULL, RTLD_LAZY);
    if (preload_lib == NULL) {
      ESMC_LogDefault.Write("ESMF Tracing/Profiling could not open shared library containing instrumentation.", ESMC_LOGMSG_WARN);
    }
    else {
      notify_wrappers = (int (*)(int)) dlsym(preload_lib, "c_esmftrace_notify_wrappers");
      if (notify_wrappers != NULL) {
        wrappersPresent = notify_wrappers(1);
      }
      else {
        ESMC_LogDefault.Write("ESMF Tracing/Profiling could not load dynamic instrumentation functions.", ESMC_LOGMSG_WARN);
      }
    }
#else
    wrappersPresent = c_esmftrace_notify_wrappers(1);
#endif
    
    if (wrappersPresent != TRACE_WRAP_NONE) {
      stringstream logMsg;
      logMsg << "ESMF Tracing/Profiling enabled with "; 
      if (wrappersPresent == TRACE_WRAP_DYNAMIC) {
        logMsg << "DYNAMIC";
      }
      else if (wrappersPresent == TRACE_WRAP_STATIC) {
        logMsg << "STATIC";
      }
      logMsg << " instrumentation.";
      ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);
      logMsg.str("  This option should only be used for profiling applications and NOT for production runs.");
      ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);
    } 
  }

#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::FinalizeWrappers()"
  static void FinalizeWrappers() {
#ifndef ESMF_NO_DLFCN      
    if (notify_wrappers != NULL) {
      notify_wrappers(0);
    }
#else
    c_esmftrace_notify_wrappers(0);
#endif
  }
  
#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceOpen()"  
  void TraceOpen(std::string trace_dir, int *profileToLog, int *rc) {

    int localrc;
    stringstream logMsg;
    
    if (rc != NULL) *rc = ESMC_RC_NOT_IMPL;

    VM *globalvm = VM::getGlobal(&localrc);
    if (ESMC_LogDefault.MsgFoundError(localrc, 
         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) 
      return;
    
    //determine if tracing is turned on for this PET
    traceLocalPet = TraceIsEnabledForPET(globalvm->getLocalPet(), &localrc);
    if (ESMC_LogDefault.MsgFoundError(localrc, 
         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {
      traceLocalPet = false;
      return;
    }

    //determine if profiling is turned on for this PET
    //if tracing is enabled, automatically turn on profiling
    profileLocalPet = traceLocalPet || ProfileIsEnabledForPET(globalvm->getLocalPet(), &localrc);
    if (ESMC_LogDefault.MsgFoundError(localrc, 
         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {
      profileLocalPet = false;
      return;
    }

    //determine output method for profiling, if enabled
    if (profileLocalPet) {
      //always output binary if tracing is enabled
      if (traceLocalPet) profileOutputToBinary = true;
      char const *envProfileOutput = VM::getenv("ESMF_RUNTIME_PROFILE_OUTPUT");
      if (envProfileOutput != NULL && strlen(envProfileOutput) > 0) {
        string profileOutput(envProfileOutput);
        if ( (profileOutput.find("TEXT") != string::npos) ||
             (profileOutput.find("text") != string::npos) ||
             (profileOutput.find("Text") != string::npos) ) {          
          if (profileToLog != NULL && *profileToLog == 1) {
            profileOutputToLog = true;
          }
          else {
            profileOutputToFile = true;
          }
        }
        if ( (profileOutput.find("BINARY") != string::npos) ||
             (profileOutput.find("binary") != string::npos) ||
             (profileOutput.find("Binary") != string::npos) ) {
          profileOutputToBinary = true;
        }
      }
      else {
        // if not specified, default is to output text
        if (profileToLog != NULL && *profileToLog == 1) {
          //printf("set output to log\n");
          profileOutputToLog = true;
        }
        else {
          //printf("set output to file\n");
          profileOutputToFile = true;
        }
      }
    }

    if (traceLocalPet) {
      ESMC_LogDefault.Write("ESMF Tracing Enabled", ESMC_LOGMSG_INFO);
    }
    if (profileLocalPet) {
      ESMC_LogDefault.Write("ESMF Profiling Enabled", ESMC_LOGMSG_INFO);
    }

    // initialize the clock
    struct esmftrc_platform_filesys_ctx *ctx;
    if (traceLocalPet || profileLocalPet) {
      ctx = FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, malloc(sizeof(*ctx))); 
      if (!ctx) {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE, "Cannot allocate context", 
                                      ESMC_CONTEXT, rc);
        return;
      }
      ctx->latch_ts = 0;
      ctx->fh == NULL;

      //store as global context
      traceCtx = ctx;
      
      TraceInitializeClock(&localrc);
      if (ESMC_LogDefault.MsgFoundError(localrc, 
           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) 
        return;
    }

    // determine if we need to set up for binary output
    if (traceLocalPet || profileOutputToBinary) {

      // stream_id same as global pet id
      int stream_id = globalvm->getLocalPet();
      ctx->stream_id = stream_id;  
      //get node name        
      if (gethostname(ctx->nodename, NODENAME_LEN) < 0) {
        ctx->nodename[0] = '\0';
      }
      
      // set up callbacks
      struct esmftrc_platform_callbacks cbs;
      cbs.sys_clock_clock_get_value = TraceGetClock;
      cbs.is_backend_full = is_backend_full;
      cbs.open_packet = open_packet;
      cbs.close_packet = close_packet;
          
      //allocate event buffer
      char const *envFlush = VM::getenv("ESMF_RUNTIME_TRACE_FLUSH");
      string strFlush = "DEFAULT";
      int eventBufSize = EVENT_BUF_SIZE_DEFAULT;
      if (envFlush != NULL) {     
        strFlush = envFlush;
        if (trim(strFlush) == "EAGER" || trim(strFlush) == "eager" || trim(strFlush) == "Eager") {
          eventBufSize = EVENT_BUF_SIZE_EAGER;
          logMsg.str("ESMF Tracing set to EAGER flushing.");
          ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);
        }
      }

      uint8_t *buf = FROM_VOID_PTR(uint8_t, malloc(eventBufSize));
      if (!buf) {
        free(ctx);
        ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE, "Cannot allocate trace event buffer", 
                                      ESMC_CONTEXT, rc);
        return;
      }
      memset(buf, 0, eventBufSize); 
    
      //make relative path absolute if needed
      string stream_dir_root;
      if (trace_dir[0] != '/') {
        char cwd[ESMC_MAXPATHLEN];
        FTN_X(c_esmc_getcwd)(cwd, &localrc, ESMC_MAXPATHLEN);
        if (ESMC_LogDefault.MsgFoundError(localrc,
           "Error getting working directory", ESMC_CONTEXT, rc))
          return;
        stream_dir_root = string (cwd, ESMC_F90lentrim(cwd, ESMC_MAXPATHLEN)) + "/" + trace_dir;
      }
      else {
        stream_dir_root = trace_dir;
      }
    
      struct stat st;
      if (stream_id == 0) {
        if (stat(stream_dir_root.c_str(), &st) == -1) {     
          ESMC_Logical relaxedFlag = ESMF_TRUE;
          int dir_perms = TRACE_DIR_PERMISSIONS;
          FTN_X(c_esmc_makedirectory)(stream_dir_root.c_str(), &dir_perms,
                                      &relaxedFlag, &localrc, stream_dir_root.length());
          
          if (ESMC_LogDefault.MsgFoundError(localrc,
                 "Error creating trace root directory", ESMC_CONTEXT, rc))
            return;
        }
      }
        
      // all PETs wait for directory to be created
      globalvm->barrier();
           
      // my specific file
      stringstream stream_file;
      stream_file << stream_dir_root << "/esmf_stream_" << std::setfill('0') << std::setw(4) << stream_id;
    
      ctx->fh = fopen(stream_file.str().c_str(), "wb");
      if (!ctx->fh) {
        free(ctx);
        free(buf);
        ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_OPEN, "Error opening trace output file", 
                                      ESMC_CONTEXT, rc);
        return;
      }

      //stream zero writes the metadata file
      if (stream_id == 0) {
        write_metadata(stream_dir_root.c_str(), &localrc);
        if (ESMC_LogDefault.MsgFoundError(localrc, 
             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {
          return;
        }
      }
          
      esmftrc_init(&ctx->ctx, buf, eventBufSize, cbs, ctx);
      open_packet(ctx);

    }  
    else {
      // this PET either has no tracing/profiling or only profiling to log/text
      globalvm->barrier();  //match barrier call above
    }
    
    if (traceLocalPet || profileLocalPet) {
      traceInitialized = true;
      // notify any function wrappers that trace is ready
      InitializeWrappers();
    }
    
    if (rc!=NULL) *rc = ESMF_SUCCESS;
    
  }

  static string getPhaseNameFromRegionId(uint16_t regionId) {
    ESMFPhaseId phaseId;
    bool present = phaseRegionMap.reverse(regionId, phaseId);
    if (present) {
      ComponentInfo *ci = NULL;
      bool present = componentInfoMap.get(phaseId.getESMFId(), ci);
      if (present && ci != NULL) {
        return ci->getPhaseName(phaseId);
      }
    }
    return "";
  }

#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::printProfile()"  
#define STATLINE 256
  static void printProfile(RegionNode *rn, bool printToLog, string prefix, ofstream &ofs, int *rc) {

    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;

    if (rn->getParent() != NULL) {
      char strname[50];
      char strbuf[STATLINE];

      //snprintf(strname, 10, "%d", rn->getId());
      string name("UNKNOWN");
      if (rn->isUserRegion()) {
        bool present = userRegionMap.reverse(rn->getId(), name);
        if (!present) {
          name = "UNKNOWN_USER_REGION";
        }
      }
      else {
        name = getPhaseNameFromRegionId(rn->getId());
        if (name.length() == 0) name = "UNKNOWN";
      }
      name.insert(0, prefix);
      
      snprintf(strbuf, STATLINE, "%-50s %-6lu %-11.4f %-11.4f %-11.4f %-11.4f %-11.4f %-11.4f",
               name.c_str(), rn->getCount(), rn->getTotal()*NANOS_TO_SECS,
               rn->getSelfTime()*NANOS_TO_SECS, rn->getMean()*NANOS_TO_SECS,
               rn->getMin()*NANOS_TO_SECS, rn->getMax()*NANOS_TO_SECS,
               rn->getTotalMPI()*NANOS_TO_SECS);
      if (printToLog) {
        ESMC_LogDefault.Write(strbuf, ESMC_LOGMSG_INFO);
      }
      else {
        ofs << strbuf << "\n";
      }
    }
    rn->sortChildren();
    for (unsigned i = 0; i < rn->getChildren().size(); i++) {
      printProfile(rn->getChildren().at(i), printToLog, prefix + "  ", ofs, rc);
    }
    if (rc!=NULL) *rc=ESMF_SUCCESS;
  }

#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::printProfile()"  
  static void printProfile(bool printToLog, int *rc) {

    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;

    ofstream ofs;
    int localrc;
    char strbuf[STATLINE];
    snprintf(strbuf, STATLINE, "%-50s %-6s %-11s %-11s %-11s %-11s %-11s %-11s",
             "Region", "Count", "Total (s)", "Self (s)", "Mean (s)", "Min (s)", "Max (s)", "MPI (s)");

    if (printToLog) {
      ESMC_LogDefault.Write("**************** Region Timings *******************", ESMC_LOGMSG_INFO);
      ESMC_LogDefault.Write(strbuf, ESMC_LOGMSG_INFO);
    }
    else {
      VM *globalvm = VM::getGlobal(&localrc);
      if (ESMC_LogDefault.MsgFoundError(localrc, 
           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) 
        return;

      stringstream fname;
      fname << (globalvm->getPetCount() - 1);
      int width = fname.str().length();
      fname.str("");
      fname << "esmf_profile." << std::setfill('0') << std::setw(width) << globalvm->getLocalPet();
      ofs.open(fname.str().c_str(), ofstream::trunc);
      if (ofs.is_open() && !ofs.fail()) {
        ofs << strbuf << "\n";
      }
      else {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, "Error opening profile output file", 
           ESMC_CONTEXT, rc);
        return;
      }
    }
    printProfile(&rootRegionNode, printToLog, "", ofs, &localrc);
    if (ESMC_LogDefault.MsgFoundError(localrc, "Error writing profile output file", 
         ESMC_CONTEXT, rc))
      return;
    if (!printToLog) {
      ofs.close();
    }
    if (rc!=NULL) *rc = ESMF_SUCCESS;
  }
  
  static void AddRegionProfilesToTrace(RegionNode *rn) {
    
    esmftrc_default_trace_region_profile(
        esmftrc_platform_get_default_ctx(),
	rn->getId(),
	rn->getParentId(),
	rn->getTotal(),
	rn->getSelfTime(),
	rn->getCount(),
	rn->getMax(),
	rn->getMin(),
	rn->getMean(),
	rn->getStdDev());
     
    for (unsigned i = 0; i < rn->getChildren().size(); i++) {
      AddRegionProfilesToTrace(rn->getChildren().at(i));
    }
  }
  
#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceClose()"
  void TraceClose(int *rc) {

    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;
    
    // allow calling multiple times, only closes
    // on the first call, needed in testing
    if (traceInitialized) {
      traceInitialized = false;
      FinalizeWrappers();

      if (profileOutputToLog) {
        printProfile(true, rc);
      }
      if (profileOutputToFile) {
        printProfile(false, rc);
      }
      if (profileOutputToBinary) {
        AddRegionProfilesToTrace(&rootRegionNode);
      }
      
      if (traceCtx != NULL) { 
        if (traceLocalPet || profileOutputToBinary) {
          if (traceCtx->fh != NULL) {
            if (esmftrc_packet_is_open(&traceCtx->ctx) &&
                !esmftrc_packet_is_empty(&traceCtx->ctx)) {
              close_packet(traceCtx);
            }
            fclose(traceCtx->fh);
          }
          free(esmftrc_packet_buf(&traceCtx->ctx));
        }
        free(traceCtx);
        traceCtx = NULL;
      }
      
      vector<HashNode<ESMFId, ComponentInfo *> *> entries = componentInfoMap.getEntries();
      vector<HashNode<ESMFId, ComponentInfo *> *>::iterator it;
      for(it = entries.begin(); it != entries.end(); it++) {
        delete (*it)->getValue();
      }
    }
    
    if(rc != NULL) *rc = ESMF_SUCCESS;
    
  }

   
  ///////////////////// I/O Tracing //////////////////

  //static std::string openFilename;
  //static uint64_t openStartTimestamp = -1;

  void TraceIOOpenStart(const char *path) {
    /*
      if (!traceLocalPet) return;    
      openStartTimestamp = TraceGetClock(NULL);
      openFilename = string(path);
    */
  }
  
  void TraceIOOpenEnd() {
    /*
    if (!traceLocalPet) return;
    uint64_t openEndTimestamp = TraceGetClock(NULL);
    uint64_t openTime = openEndTimestamp - openStartTimestamp;

    esmftrc_default_trace_ioopen(esmftrc_platform_get_default_ctx(),
                                 openFilename.c_str(), openTime);

    openStartTimestamp = -1;
    */
  }

  void TraceIOCloseStart() {
  }
  
  void TraceIOCloseEnd() {
  }

  void TraceIOWriteStart() {
  }

  void TraceIOWriteEnd(size_t nbytes) {
  }
  
  void TraceIOReadStart() {
  }

  void TraceIOReadEnd(size_t nbytes) {
  }

  /*
  static void PopIOStats() {

    size_t readBytes = readTotalBytes.back();
    uint64_t readTime = readTotalTime.back();
    readTotalBytes.pop_back();
    readTotalTime.pop_back();
    if (readBytes > 0) {
      esmftrc_default_trace_ioread(esmftrc_platform_get_default_ctx(),
                                    readBytes, readTime);
    }

    size_t writeBytes = writeTotalBytes.back();
    uint64_t writeTime = writeTotalTime.back();
    writeTotalBytes.pop_back();
    writeTotalTime.pop_back();
    if (writeBytes > 0) {
      esmftrc_default_trace_iowrite(esmftrc_platform_get_default_ctx(),
                                    writeBytes, writeTime);
    }
  }
  */
  
  ////////////////////////////////////////////////////

  /////////////////// MPI /////////////////////

  void TraceMPIWaitStart() {
    if (profileLocalPet) {
      currentRegionNode->enteredMPI(TraceGetClock(traceCtx));
    }
  }
  
  void TraceMPIWaitEnd() {
    if (profileLocalPet) {
      currentRegionNode->exitedMPI(TraceGetClock(traceCtx));
    }
  } 
  
  /*
   * This function used only in tests.
   */
  void TraceTest_GetMPIWaitStats(int *count, long long *time) {
    if (!traceInitialized) return;
    if (profileLocalPet) {
      if (count != NULL)
        *count = currentRegionNode->getCountMPI();
      if (time != NULL)
        *time = currentRegionNode->getTotalMPI();
    }
  }

  
  /////////////////////////////////////////////

#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceEventPhaseEnter()"
  void TraceEventPhaseEnter(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase, int *rc) {

    if (traceLocalPet || profileLocalPet) {
    
      int regionId = -1;
      ESMFPhaseId phaseId(ESMFId(*ep_vmid, *ep_baseid), *ep_method, *ep_phase);
      bool present = phaseRegionMap.get(phaseId, regionId);
      if (!present) {
	if (currentRegionNode == NULL) {
          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
                                        "Trace regions not properly nested", ESMC_CONTEXT, rc);
	  return;
        }
        currentRegionNode = currentRegionNode->addChild(false);
	regionId = currentRegionNode->getId();
        phaseRegionMap.put(phaseId, regionId);

        //add definition to trace
        if (traceLocalPet || profileOutputToBinary) {
          esmftrc_default_trace_define_region(esmftrc_platform_get_default_ctx(),
                                              regionId,
                                              TRACE_REGIONTYPE_PHASE,
                                              *ep_vmid, *ep_baseid, *ep_method, *ep_phase,
                                              getPhaseNameFromRegionId(regionId).c_str());
        }
      }
      else {
	currentRegionNode = currentRegionNode->getOrAddChild(regionId, false);
      }

      TraceClockLatch(traceCtx);  /* lock in time on clock */
      currentRegionNode->entered(traceCtx->latch_ts);

      if (traceLocalPet) {
        esmftrc_default_trace_regionid_enter(esmftrc_platform_get_default_ctx(),
                                             regionId);
      }
      TraceClockUnlatch(traceCtx);

    }
    
    if (rc != NULL) *rc = ESMF_SUCCESS;
    
  }

#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI:TraceEventPhaseExit()"
  void TraceEventPhaseExit(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase, int *rc) {

    if (traceLocalPet || profileLocalPet) {

      TraceClockLatch(traceCtx);
    
      int regionId = -1;
      ESMFPhaseId phaseId(ESMFId(*ep_vmid, *ep_baseid), *ep_method, *ep_phase);
      bool present = phaseRegionMap.get(phaseId, regionId);  /* should always be present */
      if (!present) {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
                                    "Trace region not properly nested", ESMC_CONTEXT, rc);
        TraceClockUnlatch(traceCtx);
        return;
      }

      if (traceLocalPet) {
        esmftrc_default_trace_regionid_exit(esmftrc_platform_get_default_ctx(),
                                            regionId);
      }
      
      if (currentRegionNode == NULL) {
	ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
				      "Trace regions not properly nested", ESMC_CONTEXT, rc);
	TraceClockUnlatch(traceCtx);
	return;
      }
      else if (currentRegionNode->getId() != regionId) {
	ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
				      "Trace regions not properly nested", ESMC_CONTEXT, rc);
	TraceClockUnlatch(traceCtx);
	return;
      }
      currentRegionNode->exited(traceCtx->latch_ts);
      currentRegionNode = currentRegionNode->getParent();
      
      TraceClockUnlatch(traceCtx);
    }
    
    if (rc!=NULL) *rc = ESMF_SUCCESS;
    
   }

  void TraceEventPhasePrologueEnter(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase) {
    if (!traceLocalPet) return;
    esmftrc_default_trace_prologue_enter(esmftrc_platform_get_default_ctx(),
                                         *ep_vmid, *ep_baseid, *ep_method, *ep_phase);
  }
  
  void TraceEventPhaseEpilogueExit(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase) {
    if (!traceLocalPet) return;
    esmftrc_default_trace_epilogue_exit(esmftrc_platform_get_default_ctx(),
                                        *ep_vmid, *ep_baseid, *ep_method, *ep_phase);
  }

#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceEventRegionEnter()"
  void TraceEventRegionEnter(std::string name, int *rc) {
    
    if (traceLocalPet || profileLocalPet) {
      int regionId = -1;
      bool present = userRegionMap.get(name, regionId);
      if (!present) {
	if (currentRegionNode == NULL) {
          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
                                        "Trace regions not properly nested", ESMC_CONTEXT, rc);
	  return;
        }
        currentRegionNode = currentRegionNode->addChild(true);
	regionId = currentRegionNode->getId();
	userRegionMap.put(name, regionId);
	
        if (traceLocalPet || profileOutputToBinary) {
          //add definition to trace          
          esmftrc_default_trace_define_region(esmftrc_platform_get_default_ctx(),
                                              regionId,
                                              TRACE_REGIONTYPE_USER,
                                              0, 0, 0, 0,
                                              name.c_str());
        }
      }
      else {
	currentRegionNode = currentRegionNode->getOrAddChild(regionId, true);
      }

      TraceClockLatch(traceCtx);
      currentRegionNode->entered(traceCtx->latch_ts);
      if (traceLocalPet) {
        esmftrc_default_trace_regionid_enter(esmftrc_platform_get_default_ctx(),
                                             regionId);
      }
      TraceClockUnlatch(traceCtx);
    }
    
    if (rc!=NULL) *rc = ESMF_SUCCESS;
  }

  void TraceEventRegionExit(std::string name, int *rc) {

    if (traceLocalPet || profileLocalPet) {
      TraceClockLatch(traceCtx);    
      int regionId = -1;
      bool present = userRegionMap.get(name, regionId);
      if (!present) {
        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
                                      "Trace region not properly nested", ESMC_CONTEXT, rc);
        TraceClockUnlatch(traceCtx);
        return;
      }
      
      if (traceLocalPet) {
        esmftrc_default_trace_regionid_exit(esmftrc_platform_get_default_ctx(),
                                            regionId);
      }

      if (currentRegionNode == NULL) {
	ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
				      "Trace regions not properly nested", ESMC_CONTEXT, rc);
	TraceClockUnlatch(traceCtx);
	return;
      }
      else if (currentRegionNode->getId() != regionId) {
	ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,
				      "Trace regions not properly nested", ESMC_CONTEXT, rc);
	TraceClockUnlatch(traceCtx);
	return;
      }
      currentRegionNode->exited(traceCtx->latch_ts);
      currentRegionNode = currentRegionNode->getParent();
      
      TraceClockUnlatch(traceCtx);
    }
    
    if (rc!=NULL) *rc = ESMF_SUCCESS;
 
  }

  //IPDv00p1=6||IPDv00p2=7||IPDv00p3=4||IPDv00p4=5::RunPhase1=1::FinalizePhase1=1
  static void UpdateComponentInfoMap(string phaseStr, ESMFId esmfId, int method, string compName) {
    ComponentInfo *ci = NULL;
    bool present = componentInfoMap.get(esmfId, ci);
    if (!present) {
      ci = new ComponentInfo(esmfId, compName);
      componentInfoMap.put(esmfId, ci);
    }
    if (ci !=NULL && phaseStr.length() > 1) {
      vector<string> phases = split(trim(phaseStr), "||");
      for (unsigned i = 0; i < phases.size(); i++) {
        vector<string> phase = split(trim(phases.at(i)), "=");
        if (phase.size() == 2) {
          int phasenum = -1;
          stringstream ss(trim(phase.at(1)));
          ss >> phasenum;
          if(!(ss.fail())) {
            ci->setPhaseName(ESMFPhaseId(esmfId, method, phasenum), phase.at(0)); 
            //std::cout << "Added region: " + compName + ", " + phase.at(0) + "\n";
          }
        }
      }
    }   
  }
  
  
#undef  ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceEventComponentInfo()"  
  void TraceEventComponentInfo(Comp *comp, int *ep_vmid, int *ep_baseid,
                               const char *ep_name, std::string attributeKeys,
                               std::string attributeVals) {

    if (traceLocalPet || profileLocalPet) {

      const vector<string> attrKeys = split(attributeKeys, "::");
      const vector<string> attrVals = split(attributeVals, "::");
      string ipm("");
      string rpm("");
      string fpm("");
      string iipm("");
      
      for (unsigned i=0; i < attrKeys.size(); i++) {
        if (attrKeys.at(i) == "IPM") {
          ipm = attrVals.at(i);
        }
        else if (attrKeys.at(i) == "RPM") {
          rpm = attrVals.at(i);
        }
        else if (attrKeys.at(i) == "FPM") {
          fpm = attrVals.at(i);
        }
        else if (attrKeys.at(i) == "IIPM") {
          iipm = attrVals.at(i);
        }
      }
      if (traceLocalPet || profileOutputToBinary) {
        esmftrc_default_trace_comp(esmftrc_platform_get_default_ctx(),
                                   *ep_vmid, *ep_baseid, ep_name,
                                   ipm.c_str(), rpm.c_str(), fpm.c_str());
      }
      if (profileLocalPet) {
        string compName(ep_name);
        ESMFId esmfId(*ep_vmid, *ep_baseid);
        UpdateComponentInfoMap(ipm, esmfId, 0, compName);
        UpdateComponentInfoMap(iipm, esmfId, 0, compName);
        UpdateComponentInfoMap(rpm, esmfId, 1, compName);
        UpdateComponentInfoMap(fpm, esmfId, 2, compName);
      }
    }
    
  }

  
#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceEventMemInfo()"
  void TraceEventMemInfo() {

    if (!traceLocalPet) return;
    
    int localrc;
    VM *globalvm = VM::getGlobal(&localrc);
    if (ESMC_LogDefault.MsgFoundError(localrc, 
          ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &localrc)) 
      return;
    
    int virtMem = -1;
    int physMem = -1;
    globalvm->getMemInfo(&virtMem, &physMem);    
    
    esmftrc_default_trace_mem(esmftrc_platform_get_default_ctx(),
                              virtMem, physMem);
    
  }

#undef ESMC_METHOD
#define ESMC_METHOD "ESMCI::TraceEventClock()"
  void TraceEventClock(int *ep_year, int *ep_month, int *ep_day,
                       int *ep_hour, int *ep_minute, int *ep_second) {
    
    if (!traceLocalPet) return;

    esmftrc_default_trace_clk(esmftrc_platform_get_default_ctx(),
                              *ep_year, *ep_month, *ep_day,
                              *ep_hour, *ep_minute, *ep_second);
    
  }

}

