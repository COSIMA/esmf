! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2018, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!====================================================================================
#define ESMF_FILENAME "src/Superstructure/AttributeAPI/interface/ESMF_Attribute.F90"
!====================================================================================

#include "ESMF.h"

module ESMF_AttributeMod

use ESMF_UtilTypesMod
use ESMF_LogErrMod
use ESMF_Info2Mod
use ESMF_InfoSyncMod
use ESMF_InitMacrosMod
use ESMF_StateTypesMod
use ESMF_ArrayMod
use ESMF_ArrayBundleMod
use ESMF_CplCompMod
use ESMF_GridCompMod
use ESMF_SciCompMod
use ESMF_DistGridMod
use ESMF_FieldMod
use ESMF_FieldBundleMod
use ESMF_GridMod
use ESMF_StateMod
use ESMF_LocStreamMod
implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:
!



public ESMF_AttPackStreamJSON


public ESMF_AttributeCopy
public ESMF_AttributeGet
public ESMF_AttributeGetAttPack


public ESMF_AttributeSet
public ESMF_AttributeRead
public ESMF_AttributeRemove
 !tdk:implement
public ESMF_AttributeWrite

!------------------------------------------------------------------------------
! !PUBLIC TYPES:
!

public ESMF_AttPack

!------------------------------------------------------------------------------

type ESMF_AttPack
  character(:), allocatable :: convention
  character(:), allocatable :: purpose
  type(ESMF_Info2), pointer :: info
endtype

interface ESMF_AttributeSet
  module procedure ESMF_AttributeSetAttPackArrayR4
  module procedure ESMF_AttributeSetAttPackArrayR4_N
  module procedure ESMF_AttributeSetAttPackArrayR8
  module procedure ESMF_AttributeSetAttPackArrayR8_N
  module procedure ESMF_AttributeSetAttPackArrayI4
  module procedure ESMF_AttributeSetAttPackArrayI4_N
  module procedure ESMF_AttributeSetAttPackArrayI8
  module procedure ESMF_AttributeSetAttPackArrayI8_N
  module procedure ESMF_AttributeSetAttPackArrayCH
  module procedure ESMF_AttributeSetAttPackArrayCH_N
  module procedure ESMF_AttributeSetAttPackArrayLG
  module procedure ESMF_AttributeSetAttPackArrayLG_N
  module procedure ESMF_AttributeSetAttPackArrayBundleR4
  module procedure ESMF_AttributeSetAttPackArrayBundleR4_N
  module procedure ESMF_AttributeSetAttPackArrayBundleR8
  module procedure ESMF_AttributeSetAttPackArrayBundleR8_N
  module procedure ESMF_AttributeSetAttPackArrayBundleI4
  module procedure ESMF_AttributeSetAttPackArrayBundleI4_N
  module procedure ESMF_AttributeSetAttPackArrayBundleI8
  module procedure ESMF_AttributeSetAttPackArrayBundleI8_N
  module procedure ESMF_AttributeSetAttPackArrayBundleCH
  module procedure ESMF_AttributeSetAttPackArrayBundleCH_N
  module procedure ESMF_AttributeSetAttPackArrayBundleLG
  module procedure ESMF_AttributeSetAttPackArrayBundleLG_N
  module procedure ESMF_AttributeSetAttPackCplCompR4
  module procedure ESMF_AttributeSetAttPackCplCompR4_N
  module procedure ESMF_AttributeSetAttPackCplCompR8
  module procedure ESMF_AttributeSetAttPackCplCompR8_N
  module procedure ESMF_AttributeSetAttPackCplCompI4
  module procedure ESMF_AttributeSetAttPackCplCompI4_N
  module procedure ESMF_AttributeSetAttPackCplCompI8
  module procedure ESMF_AttributeSetAttPackCplCompI8_N
  module procedure ESMF_AttributeSetAttPackCplCompCH
  module procedure ESMF_AttributeSetAttPackCplCompCH_N
  module procedure ESMF_AttributeSetAttPackCplCompLG
  module procedure ESMF_AttributeSetAttPackCplCompLG_N
  module procedure ESMF_AttributeSetAttPackGridCompR4
  module procedure ESMF_AttributeSetAttPackGridCompR4_N
  module procedure ESMF_AttributeSetAttPackGridCompR8
  module procedure ESMF_AttributeSetAttPackGridCompR8_N
  module procedure ESMF_AttributeSetAttPackGridCompI4
  module procedure ESMF_AttributeSetAttPackGridCompI4_N
  module procedure ESMF_AttributeSetAttPackGridCompI8
  module procedure ESMF_AttributeSetAttPackGridCompI8_N
  module procedure ESMF_AttributeSetAttPackGridCompCH
  module procedure ESMF_AttributeSetAttPackGridCompCH_N
  module procedure ESMF_AttributeSetAttPackGridCompLG
  module procedure ESMF_AttributeSetAttPackGridCompLG_N
  module procedure ESMF_AttributeSetAttPackSciCompR4
  module procedure ESMF_AttributeSetAttPackSciCompR4_N
  module procedure ESMF_AttributeSetAttPackSciCompR8
  module procedure ESMF_AttributeSetAttPackSciCompR8_N
  module procedure ESMF_AttributeSetAttPackSciCompI4
  module procedure ESMF_AttributeSetAttPackSciCompI4_N
  module procedure ESMF_AttributeSetAttPackSciCompI8
  module procedure ESMF_AttributeSetAttPackSciCompI8_N
  module procedure ESMF_AttributeSetAttPackSciCompCH
  module procedure ESMF_AttributeSetAttPackSciCompCH_N
  module procedure ESMF_AttributeSetAttPackSciCompLG
  module procedure ESMF_AttributeSetAttPackSciCompLG_N
  module procedure ESMF_AttributeSetAttPackDistGridR4
  module procedure ESMF_AttributeSetAttPackDistGridR4_N
  module procedure ESMF_AttributeSetAttPackDistGridR8
  module procedure ESMF_AttributeSetAttPackDistGridR8_N
  module procedure ESMF_AttributeSetAttPackDistGridI4
  module procedure ESMF_AttributeSetAttPackDistGridI4_N
  module procedure ESMF_AttributeSetAttPackDistGridI8
  module procedure ESMF_AttributeSetAttPackDistGridI8_N
  module procedure ESMF_AttributeSetAttPackDistGridCH
  module procedure ESMF_AttributeSetAttPackDistGridCH_N
  module procedure ESMF_AttributeSetAttPackDistGridLG
  module procedure ESMF_AttributeSetAttPackDistGridLG_N
  module procedure ESMF_AttributeSetAttPackFieldR4
  module procedure ESMF_AttributeSetAttPackFieldR4_N
  module procedure ESMF_AttributeSetAttPackFieldR8
  module procedure ESMF_AttributeSetAttPackFieldR8_N
  module procedure ESMF_AttributeSetAttPackFieldI4
  module procedure ESMF_AttributeSetAttPackFieldI4_N
  module procedure ESMF_AttributeSetAttPackFieldI8
  module procedure ESMF_AttributeSetAttPackFieldI8_N
  module procedure ESMF_AttributeSetAttPackFieldCH
  module procedure ESMF_AttributeSetAttPackFieldCH_N
  module procedure ESMF_AttributeSetAttPackFieldLG
  module procedure ESMF_AttributeSetAttPackFieldLG_N
  module procedure ESMF_AttributeSetAttPackFieldBundleR4
  module procedure ESMF_AttributeSetAttPackFieldBundleR4_N
  module procedure ESMF_AttributeSetAttPackFieldBundleR8
  module procedure ESMF_AttributeSetAttPackFieldBundleR8_N
  module procedure ESMF_AttributeSetAttPackFieldBundleI4
  module procedure ESMF_AttributeSetAttPackFieldBundleI4_N
  module procedure ESMF_AttributeSetAttPackFieldBundleI8
  module procedure ESMF_AttributeSetAttPackFieldBundleI8_N
  module procedure ESMF_AttributeSetAttPackFieldBundleCH
  module procedure ESMF_AttributeSetAttPackFieldBundleCH_N
  module procedure ESMF_AttributeSetAttPackFieldBundleLG
  module procedure ESMF_AttributeSetAttPackFieldBundleLG_N
  module procedure ESMF_AttributeSetAttPackGridR4
  module procedure ESMF_AttributeSetAttPackGridR4_N
  module procedure ESMF_AttributeSetAttPackGridR8
  module procedure ESMF_AttributeSetAttPackGridR8_N
  module procedure ESMF_AttributeSetAttPackGridI4
  module procedure ESMF_AttributeSetAttPackGridI4_N
  module procedure ESMF_AttributeSetAttPackGridI8
  module procedure ESMF_AttributeSetAttPackGridI8_N
  module procedure ESMF_AttributeSetAttPackGridCH
  module procedure ESMF_AttributeSetAttPackGridCH_N
  module procedure ESMF_AttributeSetAttPackGridLG
  module procedure ESMF_AttributeSetAttPackGridLG_N
  module procedure ESMF_AttributeSetAttPackStateR4
  module procedure ESMF_AttributeSetAttPackStateR4_N
  module procedure ESMF_AttributeSetAttPackStateR8
  module procedure ESMF_AttributeSetAttPackStateR8_N
  module procedure ESMF_AttributeSetAttPackStateI4
  module procedure ESMF_AttributeSetAttPackStateI4_N
  module procedure ESMF_AttributeSetAttPackStateI8
  module procedure ESMF_AttributeSetAttPackStateI8_N
  module procedure ESMF_AttributeSetAttPackStateCH
  module procedure ESMF_AttributeSetAttPackStateCH_N
  module procedure ESMF_AttributeSetAttPackStateLG
  module procedure ESMF_AttributeSetAttPackStateLG_N
  module procedure ESMF_AttributeSetAttPackLocStreamR4
  module procedure ESMF_AttributeSetAttPackLocStreamR4_N
  module procedure ESMF_AttributeSetAttPackLocStreamR8
  module procedure ESMF_AttributeSetAttPackLocStreamR8_N
  module procedure ESMF_AttributeSetAttPackLocStreamI4
  module procedure ESMF_AttributeSetAttPackLocStreamI4_N
  module procedure ESMF_AttributeSetAttPackLocStreamI8
  module procedure ESMF_AttributeSetAttPackLocStreamI8_N
  module procedure ESMF_AttributeSetAttPackLocStreamCH
  module procedure ESMF_AttributeSetAttPackLocStreamCH_N
  module procedure ESMF_AttributeSetAttPackLocStreamLG
  module procedure ESMF_AttributeSetAttPackLocStreamLG_N
  module procedure ESMF_AttributeSetObjArrayR4
  module procedure ESMF_AttributeSetObjArrayR4_N
  module procedure ESMF_AttributeSetObjArrayR8
  module procedure ESMF_AttributeSetObjArrayR8_N
  module procedure ESMF_AttributeSetObjArrayI4
  module procedure ESMF_AttributeSetObjArrayI4_N
  module procedure ESMF_AttributeSetObjArrayI8
  module procedure ESMF_AttributeSetObjArrayI8_N
  module procedure ESMF_AttributeSetObjArrayCH
  module procedure ESMF_AttributeSetObjArrayCH_N
  module procedure ESMF_AttributeSetObjArrayLG
  module procedure ESMF_AttributeSetObjArrayLG_N
  module procedure ESMF_AttributeSetObjArrayBundleR4
  module procedure ESMF_AttributeSetObjArrayBundleR4_N
  module procedure ESMF_AttributeSetObjArrayBundleR8
  module procedure ESMF_AttributeSetObjArrayBundleR8_N
  module procedure ESMF_AttributeSetObjArrayBundleI4
  module procedure ESMF_AttributeSetObjArrayBundleI4_N
  module procedure ESMF_AttributeSetObjArrayBundleI8
  module procedure ESMF_AttributeSetObjArrayBundleI8_N
  module procedure ESMF_AttributeSetObjArrayBundleCH
  module procedure ESMF_AttributeSetObjArrayBundleCH_N
  module procedure ESMF_AttributeSetObjArrayBundleLG
  module procedure ESMF_AttributeSetObjArrayBundleLG_N
  module procedure ESMF_AttributeSetObjCplCompR4
  module procedure ESMF_AttributeSetObjCplCompR4_N
  module procedure ESMF_AttributeSetObjCplCompR8
  module procedure ESMF_AttributeSetObjCplCompR8_N
  module procedure ESMF_AttributeSetObjCplCompI4
  module procedure ESMF_AttributeSetObjCplCompI4_N
  module procedure ESMF_AttributeSetObjCplCompI8
  module procedure ESMF_AttributeSetObjCplCompI8_N
  module procedure ESMF_AttributeSetObjCplCompCH
  module procedure ESMF_AttributeSetObjCplCompCH_N
  module procedure ESMF_AttributeSetObjCplCompLG
  module procedure ESMF_AttributeSetObjCplCompLG_N
  module procedure ESMF_AttributeSetObjGridCompR4
  module procedure ESMF_AttributeSetObjGridCompR4_N
  module procedure ESMF_AttributeSetObjGridCompR8
  module procedure ESMF_AttributeSetObjGridCompR8_N
  module procedure ESMF_AttributeSetObjGridCompI4
  module procedure ESMF_AttributeSetObjGridCompI4_N
  module procedure ESMF_AttributeSetObjGridCompI8
  module procedure ESMF_AttributeSetObjGridCompI8_N
  module procedure ESMF_AttributeSetObjGridCompCH
  module procedure ESMF_AttributeSetObjGridCompCH_N
  module procedure ESMF_AttributeSetObjGridCompLG
  module procedure ESMF_AttributeSetObjGridCompLG_N
  module procedure ESMF_AttributeSetObjSciCompR4
  module procedure ESMF_AttributeSetObjSciCompR4_N
  module procedure ESMF_AttributeSetObjSciCompR8
  module procedure ESMF_AttributeSetObjSciCompR8_N
  module procedure ESMF_AttributeSetObjSciCompI4
  module procedure ESMF_AttributeSetObjSciCompI4_N
  module procedure ESMF_AttributeSetObjSciCompI8
  module procedure ESMF_AttributeSetObjSciCompI8_N
  module procedure ESMF_AttributeSetObjSciCompCH
  module procedure ESMF_AttributeSetObjSciCompCH_N
  module procedure ESMF_AttributeSetObjSciCompLG
  module procedure ESMF_AttributeSetObjSciCompLG_N
  module procedure ESMF_AttributeSetObjDistGridR4
  module procedure ESMF_AttributeSetObjDistGridR4_N
  module procedure ESMF_AttributeSetObjDistGridR8
  module procedure ESMF_AttributeSetObjDistGridR8_N
  module procedure ESMF_AttributeSetObjDistGridI4
  module procedure ESMF_AttributeSetObjDistGridI4_N
  module procedure ESMF_AttributeSetObjDistGridI8
  module procedure ESMF_AttributeSetObjDistGridI8_N
  module procedure ESMF_AttributeSetObjDistGridCH
  module procedure ESMF_AttributeSetObjDistGridCH_N
  module procedure ESMF_AttributeSetObjDistGridLG
  module procedure ESMF_AttributeSetObjDistGridLG_N
  module procedure ESMF_AttributeSetObjFieldR4
  module procedure ESMF_AttributeSetObjFieldR4_N
  module procedure ESMF_AttributeSetObjFieldR8
  module procedure ESMF_AttributeSetObjFieldR8_N
  module procedure ESMF_AttributeSetObjFieldI4
  module procedure ESMF_AttributeSetObjFieldI4_N
  module procedure ESMF_AttributeSetObjFieldI8
  module procedure ESMF_AttributeSetObjFieldI8_N
  module procedure ESMF_AttributeSetObjFieldCH
  module procedure ESMF_AttributeSetObjFieldCH_N
  module procedure ESMF_AttributeSetObjFieldLG
  module procedure ESMF_AttributeSetObjFieldLG_N
  module procedure ESMF_AttributeSetObjFieldBundleR4
  module procedure ESMF_AttributeSetObjFieldBundleR4_N
  module procedure ESMF_AttributeSetObjFieldBundleR8
  module procedure ESMF_AttributeSetObjFieldBundleR8_N
  module procedure ESMF_AttributeSetObjFieldBundleI4
  module procedure ESMF_AttributeSetObjFieldBundleI4_N
  module procedure ESMF_AttributeSetObjFieldBundleI8
  module procedure ESMF_AttributeSetObjFieldBundleI8_N
  module procedure ESMF_AttributeSetObjFieldBundleCH
  module procedure ESMF_AttributeSetObjFieldBundleCH_N
  module procedure ESMF_AttributeSetObjFieldBundleLG
  module procedure ESMF_AttributeSetObjFieldBundleLG_N
  module procedure ESMF_AttributeSetObjGridR4
  module procedure ESMF_AttributeSetObjGridR4_N
  module procedure ESMF_AttributeSetObjGridR8
  module procedure ESMF_AttributeSetObjGridR8_N
  module procedure ESMF_AttributeSetObjGridI4
  module procedure ESMF_AttributeSetObjGridI4_N
  module procedure ESMF_AttributeSetObjGridI8
  module procedure ESMF_AttributeSetObjGridI8_N
  module procedure ESMF_AttributeSetObjGridCH
  module procedure ESMF_AttributeSetObjGridCH_N
  module procedure ESMF_AttributeSetObjGridLG
  module procedure ESMF_AttributeSetObjGridLG_N
  module procedure ESMF_AttributeSetObjStateR4
  module procedure ESMF_AttributeSetObjStateR4_N
  module procedure ESMF_AttributeSetObjStateR8
  module procedure ESMF_AttributeSetObjStateR8_N
  module procedure ESMF_AttributeSetObjStateI4
  module procedure ESMF_AttributeSetObjStateI4_N
  module procedure ESMF_AttributeSetObjStateI8
  module procedure ESMF_AttributeSetObjStateI8_N
  module procedure ESMF_AttributeSetObjStateCH
  module procedure ESMF_AttributeSetObjStateCH_N
  module procedure ESMF_AttributeSetObjStateLG
  module procedure ESMF_AttributeSetObjStateLG_N
  module procedure ESMF_AttributeSetObjLocStreamR4
  module procedure ESMF_AttributeSetObjLocStreamR4_N
  module procedure ESMF_AttributeSetObjLocStreamR8
  module procedure ESMF_AttributeSetObjLocStreamR8_N
  module procedure ESMF_AttributeSetObjLocStreamI4
  module procedure ESMF_AttributeSetObjLocStreamI4_N
  module procedure ESMF_AttributeSetObjLocStreamI8
  module procedure ESMF_AttributeSetObjLocStreamI8_N
  module procedure ESMF_AttributeSetObjLocStreamCH
  module procedure ESMF_AttributeSetObjLocStreamCH_N
  module procedure ESMF_AttributeSetObjLocStreamLG
  module procedure ESMF_AttributeSetObjLocStreamLG_N
end interface

interface ESMF_AttributeGet
  module procedure ESMF_AttributeGetAttPackArrayR4
  module procedure ESMF_AttributeGetAttPackArrayR8
  module procedure ESMF_AttributeGetAttPackArrayI4
  module procedure ESMF_AttributeGetAttPackArrayI8
  module procedure ESMF_AttributeGetAttPackArrayCH
  module procedure ESMF_AttributeGetAttPackArrayLG
  module procedure ESMF_AttributeGetAttPackArrayBundleR4
  module procedure ESMF_AttributeGetAttPackArrayBundleR8
  module procedure ESMF_AttributeGetAttPackArrayBundleI4
  module procedure ESMF_AttributeGetAttPackArrayBundleI8
  module procedure ESMF_AttributeGetAttPackArrayBundleCH
  module procedure ESMF_AttributeGetAttPackArrayBundleLG
  module procedure ESMF_AttributeGetAttPackCplCompR4
  module procedure ESMF_AttributeGetAttPackCplCompR8
  module procedure ESMF_AttributeGetAttPackCplCompI4
  module procedure ESMF_AttributeGetAttPackCplCompI8
  module procedure ESMF_AttributeGetAttPackCplCompCH
  module procedure ESMF_AttributeGetAttPackCplCompLG
  module procedure ESMF_AttributeGetAttPackGridCompR4
  module procedure ESMF_AttributeGetAttPackGridCompR8
  module procedure ESMF_AttributeGetAttPackGridCompI4
  module procedure ESMF_AttributeGetAttPackGridCompI8
  module procedure ESMF_AttributeGetAttPackGridCompCH
  module procedure ESMF_AttributeGetAttPackGridCompLG
  module procedure ESMF_AttributeGetAttPackSciCompR4
  module procedure ESMF_AttributeGetAttPackSciCompR8
  module procedure ESMF_AttributeGetAttPackSciCompI4
  module procedure ESMF_AttributeGetAttPackSciCompI8
  module procedure ESMF_AttributeGetAttPackSciCompCH
  module procedure ESMF_AttributeGetAttPackSciCompLG
  module procedure ESMF_AttributeGetAttPackDistGridR4
  module procedure ESMF_AttributeGetAttPackDistGridR8
  module procedure ESMF_AttributeGetAttPackDistGridI4
  module procedure ESMF_AttributeGetAttPackDistGridI8
  module procedure ESMF_AttributeGetAttPackDistGridCH
  module procedure ESMF_AttributeGetAttPackDistGridLG
  module procedure ESMF_AttributeGetAttPackFieldR4
  module procedure ESMF_AttributeGetAttPackFieldR8
  module procedure ESMF_AttributeGetAttPackFieldI4
  module procedure ESMF_AttributeGetAttPackFieldI8
  module procedure ESMF_AttributeGetAttPackFieldCH
  module procedure ESMF_AttributeGetAttPackFieldLG
  module procedure ESMF_AttributeGetAttPackFieldBundleR4
  module procedure ESMF_AttributeGetAttPackFieldBundleR8
  module procedure ESMF_AttributeGetAttPackFieldBundleI4
  module procedure ESMF_AttributeGetAttPackFieldBundleI8
  module procedure ESMF_AttributeGetAttPackFieldBundleCH
  module procedure ESMF_AttributeGetAttPackFieldBundleLG
  module procedure ESMF_AttributeGetAttPackGridR4
  module procedure ESMF_AttributeGetAttPackGridR8
  module procedure ESMF_AttributeGetAttPackGridI4
  module procedure ESMF_AttributeGetAttPackGridI8
  module procedure ESMF_AttributeGetAttPackGridCH
  module procedure ESMF_AttributeGetAttPackGridLG
  module procedure ESMF_AttributeGetAttPackStateR4
  module procedure ESMF_AttributeGetAttPackStateR8
  module procedure ESMF_AttributeGetAttPackStateI4
  module procedure ESMF_AttributeGetAttPackStateI8
  module procedure ESMF_AttributeGetAttPackStateCH
  module procedure ESMF_AttributeGetAttPackStateLG
  module procedure ESMF_AttributeGetAttPackLocStreamR4
  module procedure ESMF_AttributeGetAttPackLocStreamR8
  module procedure ESMF_AttributeGetAttPackLocStreamI4
  module procedure ESMF_AttributeGetAttPackLocStreamI8
  module procedure ESMF_AttributeGetAttPackLocStreamCH
  module procedure ESMF_AttributeGetAttPackLocStreamLG
  module procedure ESMF_AttributeGetObjArrayR4
  module procedure ESMF_AttributeGetObjArrayR8
  module procedure ESMF_AttributeGetObjArrayI4
  module procedure ESMF_AttributeGetObjArrayI8
  module procedure ESMF_AttributeGetObjArrayCH
  module procedure ESMF_AttributeGetObjArrayLG
  module procedure ESMF_AttributeGetObjArrayBundleR4
  module procedure ESMF_AttributeGetObjArrayBundleR8
  module procedure ESMF_AttributeGetObjArrayBundleI4
  module procedure ESMF_AttributeGetObjArrayBundleI8
  module procedure ESMF_AttributeGetObjArrayBundleCH
  module procedure ESMF_AttributeGetObjArrayBundleLG
  module procedure ESMF_AttributeGetObjCplCompR4
  module procedure ESMF_AttributeGetObjCplCompR8
  module procedure ESMF_AttributeGetObjCplCompI4
  module procedure ESMF_AttributeGetObjCplCompI8
  module procedure ESMF_AttributeGetObjCplCompCH
  module procedure ESMF_AttributeGetObjCplCompLG
  module procedure ESMF_AttributeGetObjGridCompR4
  module procedure ESMF_AttributeGetObjGridCompR8
  module procedure ESMF_AttributeGetObjGridCompI4
  module procedure ESMF_AttributeGetObjGridCompI8
  module procedure ESMF_AttributeGetObjGridCompCH
  module procedure ESMF_AttributeGetObjGridCompLG
  module procedure ESMF_AttributeGetObjSciCompR4
  module procedure ESMF_AttributeGetObjSciCompR8
  module procedure ESMF_AttributeGetObjSciCompI4
  module procedure ESMF_AttributeGetObjSciCompI8
  module procedure ESMF_AttributeGetObjSciCompCH
  module procedure ESMF_AttributeGetObjSciCompLG
  module procedure ESMF_AttributeGetObjDistGridR4
  module procedure ESMF_AttributeGetObjDistGridR8
  module procedure ESMF_AttributeGetObjDistGridI4
  module procedure ESMF_AttributeGetObjDistGridI8
  module procedure ESMF_AttributeGetObjDistGridCH
  module procedure ESMF_AttributeGetObjDistGridLG
  module procedure ESMF_AttributeGetObjFieldR4
  module procedure ESMF_AttributeGetObjFieldR8
  module procedure ESMF_AttributeGetObjFieldI4
  module procedure ESMF_AttributeGetObjFieldI8
  module procedure ESMF_AttributeGetObjFieldCH
  module procedure ESMF_AttributeGetObjFieldLG
  module procedure ESMF_AttributeGetObjFieldBundleR4
  module procedure ESMF_AttributeGetObjFieldBundleR8
  module procedure ESMF_AttributeGetObjFieldBundleI4
  module procedure ESMF_AttributeGetObjFieldBundleI8
  module procedure ESMF_AttributeGetObjFieldBundleCH
  module procedure ESMF_AttributeGetObjFieldBundleLG
  module procedure ESMF_AttributeGetObjGridR4
  module procedure ESMF_AttributeGetObjGridR8
  module procedure ESMF_AttributeGetObjGridI4
  module procedure ESMF_AttributeGetObjGridI8
  module procedure ESMF_AttributeGetObjGridCH
  module procedure ESMF_AttributeGetObjGridLG
  module procedure ESMF_AttributeGetObjStateR4
  module procedure ESMF_AttributeGetObjStateR8
  module procedure ESMF_AttributeGetObjStateI4
  module procedure ESMF_AttributeGetObjStateI8
  module procedure ESMF_AttributeGetObjStateCH
  module procedure ESMF_AttributeGetObjStateLG
  module procedure ESMF_AttributeGetObjLocStreamR4
  module procedure ESMF_AttributeGetObjLocStreamR8
  module procedure ESMF_AttributeGetObjLocStreamI4
  module procedure ESMF_AttributeGetObjLocStreamI8
  module procedure ESMF_AttributeGetObjLocStreamCH
  module procedure ESMF_AttributeGetObjLocStreamLG
  module procedure ESMF_AttributeGetListAttPackArrayR4
  module procedure ESMF_AttributeGetListAttPackArrayR8
  module procedure ESMF_AttributeGetListAttPackArrayI4
  module procedure ESMF_AttributeGetListAttPackArrayI8
  module procedure ESMF_AttributeGetListAttPackArrayCH
  module procedure ESMF_AttributeGetListAttPackArrayLG
  module procedure ESMF_AttributeGetListAttPackArrayBundleR4
  module procedure ESMF_AttributeGetListAttPackArrayBundleR8
  module procedure ESMF_AttributeGetListAttPackArrayBundleI4
  module procedure ESMF_AttributeGetListAttPackArrayBundleI8
  module procedure ESMF_AttributeGetListAttPackArrayBundleCH
  module procedure ESMF_AttributeGetListAttPackArrayBundleLG
  module procedure ESMF_AttributeGetListAttPackCplCompR4
  module procedure ESMF_AttributeGetListAttPackCplCompR8
  module procedure ESMF_AttributeGetListAttPackCplCompI4
  module procedure ESMF_AttributeGetListAttPackCplCompI8
  module procedure ESMF_AttributeGetListAttPackCplCompCH
  module procedure ESMF_AttributeGetListAttPackCplCompLG
  module procedure ESMF_AttributeGetListAttPackGridCompR4
  module procedure ESMF_AttributeGetListAttPackGridCompR8
  module procedure ESMF_AttributeGetListAttPackGridCompI4
  module procedure ESMF_AttributeGetListAttPackGridCompI8
  module procedure ESMF_AttributeGetListAttPackGridCompCH
  module procedure ESMF_AttributeGetListAttPackGridCompLG
  module procedure ESMF_AttributeGetListAttPackSciCompR4
  module procedure ESMF_AttributeGetListAttPackSciCompR8
  module procedure ESMF_AttributeGetListAttPackSciCompI4
  module procedure ESMF_AttributeGetListAttPackSciCompI8
  module procedure ESMF_AttributeGetListAttPackSciCompCH
  module procedure ESMF_AttributeGetListAttPackSciCompLG
  module procedure ESMF_AttributeGetListAttPackDistGridR4
  module procedure ESMF_AttributeGetListAttPackDistGridR8
  module procedure ESMF_AttributeGetListAttPackDistGridI4
  module procedure ESMF_AttributeGetListAttPackDistGridI8
  module procedure ESMF_AttributeGetListAttPackDistGridCH
  module procedure ESMF_AttributeGetListAttPackDistGridLG
  module procedure ESMF_AttributeGetListAttPackFieldR4
  module procedure ESMF_AttributeGetListAttPackFieldR8
  module procedure ESMF_AttributeGetListAttPackFieldI4
  module procedure ESMF_AttributeGetListAttPackFieldI8
  module procedure ESMF_AttributeGetListAttPackFieldCH
  module procedure ESMF_AttributeGetListAttPackFieldLG
  module procedure ESMF_AttributeGetListAttPackFieldBundleR4
  module procedure ESMF_AttributeGetListAttPackFieldBundleR8
  module procedure ESMF_AttributeGetListAttPackFieldBundleI4
  module procedure ESMF_AttributeGetListAttPackFieldBundleI8
  module procedure ESMF_AttributeGetListAttPackFieldBundleCH
  module procedure ESMF_AttributeGetListAttPackFieldBundleLG
  module procedure ESMF_AttributeGetListAttPackGridR4
  module procedure ESMF_AttributeGetListAttPackGridR8
  module procedure ESMF_AttributeGetListAttPackGridI4
  module procedure ESMF_AttributeGetListAttPackGridI8
  module procedure ESMF_AttributeGetListAttPackGridCH
  module procedure ESMF_AttributeGetListAttPackGridLG
  module procedure ESMF_AttributeGetListAttPackStateR4
  module procedure ESMF_AttributeGetListAttPackStateR8
  module procedure ESMF_AttributeGetListAttPackStateI4
  module procedure ESMF_AttributeGetListAttPackStateI8
  module procedure ESMF_AttributeGetListAttPackStateCH
  module procedure ESMF_AttributeGetListAttPackStateLG
  module procedure ESMF_AttributeGetListAttPackLocStreamR4
  module procedure ESMF_AttributeGetListAttPackLocStreamR8
  module procedure ESMF_AttributeGetListAttPackLocStreamI4
  module procedure ESMF_AttributeGetListAttPackLocStreamI8
  module procedure ESMF_AttributeGetListAttPackLocStreamCH
  module procedure ESMF_AttributeGetListAttPackLocStreamLG
  module procedure ESMF_AttributeGetListObjArrayR4
  module procedure ESMF_AttributeGetListObjArrayR8
  module procedure ESMF_AttributeGetListObjArrayI4
  module procedure ESMF_AttributeGetListObjArrayI8
  module procedure ESMF_AttributeGetListObjArrayCH
  module procedure ESMF_AttributeGetListObjArrayLG
  module procedure ESMF_AttributeGetListObjArrayBundleR4
  module procedure ESMF_AttributeGetListObjArrayBundleR8
  module procedure ESMF_AttributeGetListObjArrayBundleI4
  module procedure ESMF_AttributeGetListObjArrayBundleI8
  module procedure ESMF_AttributeGetListObjArrayBundleCH
  module procedure ESMF_AttributeGetListObjArrayBundleLG
  module procedure ESMF_AttributeGetListObjCplCompR4
  module procedure ESMF_AttributeGetListObjCplCompR8
  module procedure ESMF_AttributeGetListObjCplCompI4
  module procedure ESMF_AttributeGetListObjCplCompI8
  module procedure ESMF_AttributeGetListObjCplCompCH
  module procedure ESMF_AttributeGetListObjCplCompLG
  module procedure ESMF_AttributeGetListObjGridCompR4
  module procedure ESMF_AttributeGetListObjGridCompR8
  module procedure ESMF_AttributeGetListObjGridCompI4
  module procedure ESMF_AttributeGetListObjGridCompI8
  module procedure ESMF_AttributeGetListObjGridCompCH
  module procedure ESMF_AttributeGetListObjGridCompLG
  module procedure ESMF_AttributeGetListObjSciCompR4
  module procedure ESMF_AttributeGetListObjSciCompR8
  module procedure ESMF_AttributeGetListObjSciCompI4
  module procedure ESMF_AttributeGetListObjSciCompI8
  module procedure ESMF_AttributeGetListObjSciCompCH
  module procedure ESMF_AttributeGetListObjSciCompLG
  module procedure ESMF_AttributeGetListObjDistGridR4
  module procedure ESMF_AttributeGetListObjDistGridR8
  module procedure ESMF_AttributeGetListObjDistGridI4
  module procedure ESMF_AttributeGetListObjDistGridI8
  module procedure ESMF_AttributeGetListObjDistGridCH
  module procedure ESMF_AttributeGetListObjDistGridLG
  module procedure ESMF_AttributeGetListObjFieldR4
  module procedure ESMF_AttributeGetListObjFieldR8
  module procedure ESMF_AttributeGetListObjFieldI4
  module procedure ESMF_AttributeGetListObjFieldI8
  module procedure ESMF_AttributeGetListObjFieldCH
  module procedure ESMF_AttributeGetListObjFieldLG
  module procedure ESMF_AttributeGetListObjFieldBundleR4
  module procedure ESMF_AttributeGetListObjFieldBundleR8
  module procedure ESMF_AttributeGetListObjFieldBundleI4
  module procedure ESMF_AttributeGetListObjFieldBundleI8
  module procedure ESMF_AttributeGetListObjFieldBundleCH
  module procedure ESMF_AttributeGetListObjFieldBundleLG
  module procedure ESMF_AttributeGetListObjGridR4
  module procedure ESMF_AttributeGetListObjGridR8
  module procedure ESMF_AttributeGetListObjGridI4
  module procedure ESMF_AttributeGetListObjGridI8
  module procedure ESMF_AttributeGetListObjGridCH
  module procedure ESMF_AttributeGetListObjGridLG
  module procedure ESMF_AttributeGetListObjStateR4
  module procedure ESMF_AttributeGetListObjStateR8
  module procedure ESMF_AttributeGetListObjStateI4
  module procedure ESMF_AttributeGetListObjStateI8
  module procedure ESMF_AttributeGetListObjStateCH
  module procedure ESMF_AttributeGetListObjStateLG
  module procedure ESMF_AttributeGetListObjLocStreamR4
  module procedure ESMF_AttributeGetListObjLocStreamR8
  module procedure ESMF_AttributeGetListObjLocStreamI4
  module procedure ESMF_AttributeGetListObjLocStreamI8
  module procedure ESMF_AttributeGetListObjLocStreamCH
  module procedure ESMF_AttributeGetListObjLocStreamLG

  module procedure ESMF_AttributeGetCountArray
  module procedure ESMF_AttributeGetCountArrayBundle
  module procedure ESMF_AttributeGetCountCplComp
  module procedure ESMF_AttributeGetCountGridComp
  module procedure ESMF_AttributeGetCountSciComp
  module procedure ESMF_AttributeGetCountDistGrid
  module procedure ESMF_AttributeGetCountField
  module procedure ESMF_AttributeGetCountFieldBundle
  module procedure ESMF_AttributeGetCountGrid
  module procedure ESMF_AttributeGetCountState
  module procedure ESMF_AttributeGetCountLocStream
  module procedure ESMF_AttributeGetInfoByNamAPArray
  module procedure ESMF_AttributeGetInfoByNamAPArrayBundle
  module procedure ESMF_AttributeGetInfoByNamAPCplComp
  module procedure ESMF_AttributeGetInfoByNamAPGridComp
  module procedure ESMF_AttributeGetInfoByNamAPSciComp
  module procedure ESMF_AttributeGetInfoByNamAPDistGrid
  module procedure ESMF_AttributeGetInfoByNamAPField
  module procedure ESMF_AttributeGetInfoByNamAPFieldBundle
  module procedure ESMF_AttributeGetInfoByNamAPGrid
  module procedure ESMF_AttributeGetInfoByNamAPState
  module procedure ESMF_AttributeGetInfoByNamAPLocStream
  module procedure ESMF_AttributeGetInfoByNamArray
  module procedure ESMF_AttributeGetInfoByNamArrayBundle
  module procedure ESMF_AttributeGetInfoByNamCplComp
  module procedure ESMF_AttributeGetInfoByNamGridComp
  module procedure ESMF_AttributeGetInfoByNamSciComp
  module procedure ESMF_AttributeGetInfoByNamDistGrid
  module procedure ESMF_AttributeGetInfoByNamField
  module procedure ESMF_AttributeGetInfoByNamFieldBundle
  module procedure ESMF_AttributeGetInfoByNamGrid
  module procedure ESMF_AttributeGetInfoByNamState
  module procedure ESMF_AttributeGetInfoByNamLocStream
  module procedure ESMF_AttributeGetInfoByNumArray
  module procedure ESMF_AttributeGetInfoByNumArrayBundle
  module procedure ESMF_AttributeGetInfoByNumCplComp
  module procedure ESMF_AttributeGetInfoByNumGridComp
  module procedure ESMF_AttributeGetInfoByNumSciComp
  module procedure ESMF_AttributeGetInfoByNumDistGrid
  module procedure ESMF_AttributeGetInfoByNumField
  module procedure ESMF_AttributeGetInfoByNumFieldBundle
  module procedure ESMF_AttributeGetInfoByNumGrid
  module procedure ESMF_AttributeGetInfoByNumState
  module procedure ESMF_AttributeGetInfoByNumLocStream
  
end interface

interface ESMF_AttributeGetAttPack
  module procedure ESMF_AttributeGetAttPackArray
  module procedure ESMF_AttributeGetAttPackArrayBundle
  module procedure ESMF_AttributeGetAttPackCplComp
  module procedure ESMF_AttributeGetAttPackGridComp
  module procedure ESMF_AttributeGetAttPackSciComp
  module procedure ESMF_AttributeGetAttPackDistGrid
  module procedure ESMF_AttributeGetAttPackField
  module procedure ESMF_AttributeGetAttPackFieldBundle
  module procedure ESMF_AttributeGetAttPackGrid
  module procedure ESMF_AttributeGetAttPackState
  module procedure ESMF_AttributeGetAttPackLocStream
end interface


interface ESMF_AttributeRemove
  module procedure ESMF_AttributeRemoveAttPackArray
  module procedure ESMF_AttributeRemoveAttPackArrayBundle
  module procedure ESMF_AttributeRemoveAttPackCplComp
  module procedure ESMF_AttributeRemoveAttPackGridComp
  module procedure ESMF_AttributeRemoveAttPackSciComp
  module procedure ESMF_AttributeRemoveAttPackDistGrid
  module procedure ESMF_AttributeRemoveAttPackField
  module procedure ESMF_AttributeRemoveAttPackFieldBundle
  module procedure ESMF_AttributeRemoveAttPackGrid
  module procedure ESMF_AttributeRemoveAttPackState
  module procedure ESMF_AttributeRemoveAttPackLocStream
end interface

interface ESMF_AttributeCopy
  module procedure ESMF_AttributeCopyArray
  module procedure ESMF_AttributeCopyArrayBundle
  module procedure ESMF_AttributeCopyCplComp
  module procedure ESMF_AttributeCopyGridComp
  module procedure ESMF_AttributeCopySciComp
  module procedure ESMF_AttributeCopyDistGrid
  module procedure ESMF_AttributeCopyField
  module procedure ESMF_AttributeCopyFieldBundle
  module procedure ESMF_AttributeCopyGrid
  module procedure ESMF_AttributeCopyState
  module procedure ESMF_AttributeCopyLocStream
end interface

interface ESMF_AttributeRead
  module procedure ESMF_AttributeReadArray
  module procedure ESMF_AttributeReadArrayBundle
  module procedure ESMF_AttributeReadCplComp
  module procedure ESMF_AttributeReadGridComp
  module procedure ESMF_AttributeReadSciComp
  module procedure ESMF_AttributeReadDistGrid
  module procedure ESMF_AttributeReadField
  module procedure ESMF_AttributeReadFieldBundle
  module procedure ESMF_AttributeReadGrid
  module procedure ESMF_AttributeReadState
  module procedure ESMF_AttributeReadLocStream
end interface

interface ESMF_AttributeWrite
  module procedure ESMF_AttributeWriteArray
  module procedure ESMF_AttributeWriteArrayBundle
  module procedure ESMF_AttributeWriteCplComp
  module procedure ESMF_AttributeWriteGridComp
  module procedure ESMF_AttributeWriteSciComp
  module procedure ESMF_AttributeWriteDistGrid
  module procedure ESMF_AttributeWriteField
  module procedure ESMF_AttributeWriteFieldBundle
  module procedure ESMF_AttributeWriteGrid
  module procedure ESMF_AttributeWriteState
  module procedure ESMF_AttributeWriteLocStream
end interface

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
character(*), parameter, private :: version = '$Id$'
!------------------------------------------------------------------------------

character(*), parameter :: ESMF_ATTR_DEFAULT_CONVENTION="ESMF"
character(*), parameter :: ESMF_ATTR_DEFAULT_PURPOSE   ="General"
character(*), parameter :: ESMF_ATTR_DEFAULT_ROOTKEY   ="/ESMF/General/"
     logical, parameter :: ESMF_ATTR_DEFAULT_FORCE     =.true.

contains  !====================================================================

!==============================================================================
! Helper Functions ============================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "format_key()"
subroutine format_key(key, name, rc, convention, purpose)
  character(:), allocatable, intent(out) :: key
  character(len=*), intent(in) :: name
  integer, intent(inout) :: rc
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer :: len_key
  character(*), parameter :: msg="Both convention & purpose are required if either is present"

  if (present(convention)) then
    if (.not. present(purpose)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg=msg, ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif
  if (present(purpose)) then
    if (.not. present(convention)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg=msg, ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  !tdk:todo: can avoid key allocate and deallocate by just setting
  if (present(convention)) then
    if (len(name) > 0) then
      len_key = len(trim(convention)) + len(trim(purpose)) + len(trim(name)) + 3
    else
      len_key = len(trim(convention)) + len(trim(purpose)) + 2
    end if
  else
    len_key = 14 + len(trim(name))
  endif

  allocate(character(len_key)::key)
  if (present(convention)) then
    if (len(name) > 0) then
      key = "/"//trim(convention)//"/"//trim(purpose)//"/"//trim(name)
    else
      key = "/"//trim(convention)//"/"//trim(purpose)
    end if
  else
    key = ESMF_ATTR_DEFAULT_ROOTKEY//"/"//trim(name)
  endif

end subroutine format_key

#undef  ESMF_METHOD
#define ESMF_METHOD "validate_attpack()"
subroutine validate_attpack(attpack, rc)
  type(ESMF_AttPack), intent(in) :: attpack
  integer, intent(inout) :: rc
  if (.not. associated(attpack%info)) then
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="attpack%info must be associated", ESMF_CONTEXT, rcToReturn=rc)) return
  else
    rc = ESMF_SUCCESS
  endif
end subroutine validate_attpack

!==============================================================================
! ESMF_AttributeSet ===========================================================
!==============================================================================


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayR4()"
subroutine ESMF_AttributeSetAttPackArrayR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayR4()"
subroutine ESMF_AttributeSetObjArrayR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayR4_N()"
subroutine ESMF_AttributeSetAttPackArrayR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayR4_N()"
subroutine ESMF_AttributeSetObjArrayR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayR8()"
subroutine ESMF_AttributeSetAttPackArrayR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayR8()"
subroutine ESMF_AttributeSetObjArrayR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayR8_N()"
subroutine ESMF_AttributeSetAttPackArrayR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayR8_N()"
subroutine ESMF_AttributeSetObjArrayR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayI4()"
subroutine ESMF_AttributeSetAttPackArrayI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayI4()"
subroutine ESMF_AttributeSetObjArrayI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayI4_N()"
subroutine ESMF_AttributeSetAttPackArrayI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayI4_N()"
subroutine ESMF_AttributeSetObjArrayI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayI8()"
subroutine ESMF_AttributeSetAttPackArrayI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayI8()"
subroutine ESMF_AttributeSetObjArrayI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayI8_N()"
subroutine ESMF_AttributeSetAttPackArrayI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayI8_N()"
subroutine ESMF_AttributeSetObjArrayI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayCH()"
subroutine ESMF_AttributeSetAttPackArrayCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayCH()"
subroutine ESMF_AttributeSetObjArrayCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayCH_N()"
subroutine ESMF_AttributeSetAttPackArrayCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayCH_N()"
subroutine ESMF_AttributeSetObjArrayCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayLG()"
subroutine ESMF_AttributeSetAttPackArrayLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayLG()"
subroutine ESMF_AttributeSetObjArrayLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayLG_N()"
subroutine ESMF_AttributeSetAttPackArrayLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayLG_N()"
subroutine ESMF_AttributeSetObjArrayLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleR4()"
subroutine ESMF_AttributeSetAttPackArrayBundleR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleR4()"
subroutine ESMF_AttributeSetObjArrayBundleR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleR4_N()"
subroutine ESMF_AttributeSetAttPackArrayBundleR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleR4_N()"
subroutine ESMF_AttributeSetObjArrayBundleR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleR8()"
subroutine ESMF_AttributeSetAttPackArrayBundleR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleR8()"
subroutine ESMF_AttributeSetObjArrayBundleR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleR8_N()"
subroutine ESMF_AttributeSetAttPackArrayBundleR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleR8_N()"
subroutine ESMF_AttributeSetObjArrayBundleR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleI4()"
subroutine ESMF_AttributeSetAttPackArrayBundleI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleI4()"
subroutine ESMF_AttributeSetObjArrayBundleI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleI4_N()"
subroutine ESMF_AttributeSetAttPackArrayBundleI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleI4_N()"
subroutine ESMF_AttributeSetObjArrayBundleI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleI8()"
subroutine ESMF_AttributeSetAttPackArrayBundleI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleI8()"
subroutine ESMF_AttributeSetObjArrayBundleI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleI8_N()"
subroutine ESMF_AttributeSetAttPackArrayBundleI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleI8_N()"
subroutine ESMF_AttributeSetObjArrayBundleI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleCH()"
subroutine ESMF_AttributeSetAttPackArrayBundleCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleCH()"
subroutine ESMF_AttributeSetObjArrayBundleCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleCH_N()"
subroutine ESMF_AttributeSetAttPackArrayBundleCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleCH_N()"
subroutine ESMF_AttributeSetObjArrayBundleCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleLG()"
subroutine ESMF_AttributeSetAttPackArrayBundleLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleLG()"
subroutine ESMF_AttributeSetObjArrayBundleLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackArrayBundleLG_N()"
subroutine ESMF_AttributeSetAttPackArrayBundleLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackArrayBundleLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjArrayBundleLG_N()"
subroutine ESMF_AttributeSetObjArrayBundleLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjArrayBundleLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompR4()"
subroutine ESMF_AttributeSetAttPackCplCompR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompR4()"
subroutine ESMF_AttributeSetObjCplCompR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompR4_N()"
subroutine ESMF_AttributeSetAttPackCplCompR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompR4_N()"
subroutine ESMF_AttributeSetObjCplCompR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompR8()"
subroutine ESMF_AttributeSetAttPackCplCompR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompR8()"
subroutine ESMF_AttributeSetObjCplCompR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompR8_N()"
subroutine ESMF_AttributeSetAttPackCplCompR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompR8_N()"
subroutine ESMF_AttributeSetObjCplCompR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompI4()"
subroutine ESMF_AttributeSetAttPackCplCompI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompI4()"
subroutine ESMF_AttributeSetObjCplCompI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompI4_N()"
subroutine ESMF_AttributeSetAttPackCplCompI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompI4_N()"
subroutine ESMF_AttributeSetObjCplCompI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompI8()"
subroutine ESMF_AttributeSetAttPackCplCompI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompI8()"
subroutine ESMF_AttributeSetObjCplCompI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompI8_N()"
subroutine ESMF_AttributeSetAttPackCplCompI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompI8_N()"
subroutine ESMF_AttributeSetObjCplCompI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompCH()"
subroutine ESMF_AttributeSetAttPackCplCompCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompCH()"
subroutine ESMF_AttributeSetObjCplCompCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompCH_N()"
subroutine ESMF_AttributeSetAttPackCplCompCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompCH_N()"
subroutine ESMF_AttributeSetObjCplCompCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompLG()"
subroutine ESMF_AttributeSetAttPackCplCompLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompLG()"
subroutine ESMF_AttributeSetObjCplCompLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackCplCompLG_N()"
subroutine ESMF_AttributeSetAttPackCplCompLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackCplCompLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjCplCompLG_N()"
subroutine ESMF_AttributeSetObjCplCompLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjCplCompLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompR4()"
subroutine ESMF_AttributeSetAttPackGridCompR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompR4()"
subroutine ESMF_AttributeSetObjGridCompR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompR4_N()"
subroutine ESMF_AttributeSetAttPackGridCompR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompR4_N()"
subroutine ESMF_AttributeSetObjGridCompR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompR8()"
subroutine ESMF_AttributeSetAttPackGridCompR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompR8()"
subroutine ESMF_AttributeSetObjGridCompR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompR8_N()"
subroutine ESMF_AttributeSetAttPackGridCompR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompR8_N()"
subroutine ESMF_AttributeSetObjGridCompR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompI4()"
subroutine ESMF_AttributeSetAttPackGridCompI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompI4()"
subroutine ESMF_AttributeSetObjGridCompI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompI4_N()"
subroutine ESMF_AttributeSetAttPackGridCompI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompI4_N()"
subroutine ESMF_AttributeSetObjGridCompI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompI8()"
subroutine ESMF_AttributeSetAttPackGridCompI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompI8()"
subroutine ESMF_AttributeSetObjGridCompI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompI8_N()"
subroutine ESMF_AttributeSetAttPackGridCompI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompI8_N()"
subroutine ESMF_AttributeSetObjGridCompI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompCH()"
subroutine ESMF_AttributeSetAttPackGridCompCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompCH()"
subroutine ESMF_AttributeSetObjGridCompCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompCH_N()"
subroutine ESMF_AttributeSetAttPackGridCompCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompCH_N()"
subroutine ESMF_AttributeSetObjGridCompCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompLG()"
subroutine ESMF_AttributeSetAttPackGridCompLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompLG()"
subroutine ESMF_AttributeSetObjGridCompLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCompLG_N()"
subroutine ESMF_AttributeSetAttPackGridCompLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCompLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCompLG_N()"
subroutine ESMF_AttributeSetObjGridCompLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCompLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompR4()"
subroutine ESMF_AttributeSetAttPackSciCompR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompR4()"
subroutine ESMF_AttributeSetObjSciCompR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompR4_N()"
subroutine ESMF_AttributeSetAttPackSciCompR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompR4_N()"
subroutine ESMF_AttributeSetObjSciCompR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompR8()"
subroutine ESMF_AttributeSetAttPackSciCompR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompR8()"
subroutine ESMF_AttributeSetObjSciCompR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompR8_N()"
subroutine ESMF_AttributeSetAttPackSciCompR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompR8_N()"
subroutine ESMF_AttributeSetObjSciCompR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompI4()"
subroutine ESMF_AttributeSetAttPackSciCompI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompI4()"
subroutine ESMF_AttributeSetObjSciCompI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompI4_N()"
subroutine ESMF_AttributeSetAttPackSciCompI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompI4_N()"
subroutine ESMF_AttributeSetObjSciCompI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompI8()"
subroutine ESMF_AttributeSetAttPackSciCompI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompI8()"
subroutine ESMF_AttributeSetObjSciCompI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompI8_N()"
subroutine ESMF_AttributeSetAttPackSciCompI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompI8_N()"
subroutine ESMF_AttributeSetObjSciCompI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompCH()"
subroutine ESMF_AttributeSetAttPackSciCompCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompCH()"
subroutine ESMF_AttributeSetObjSciCompCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompCH_N()"
subroutine ESMF_AttributeSetAttPackSciCompCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompCH_N()"
subroutine ESMF_AttributeSetObjSciCompCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompLG()"
subroutine ESMF_AttributeSetAttPackSciCompLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompLG()"
subroutine ESMF_AttributeSetObjSciCompLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackSciCompLG_N()"
subroutine ESMF_AttributeSetAttPackSciCompLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackSciCompLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjSciCompLG_N()"
subroutine ESMF_AttributeSetObjSciCompLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjSciCompLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridR4()"
subroutine ESMF_AttributeSetAttPackDistGridR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridR4()"
subroutine ESMF_AttributeSetObjDistGridR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridR4_N()"
subroutine ESMF_AttributeSetAttPackDistGridR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridR4_N()"
subroutine ESMF_AttributeSetObjDistGridR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridR8()"
subroutine ESMF_AttributeSetAttPackDistGridR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridR8()"
subroutine ESMF_AttributeSetObjDistGridR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridR8_N()"
subroutine ESMF_AttributeSetAttPackDistGridR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridR8_N()"
subroutine ESMF_AttributeSetObjDistGridR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridI4()"
subroutine ESMF_AttributeSetAttPackDistGridI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridI4()"
subroutine ESMF_AttributeSetObjDistGridI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridI4_N()"
subroutine ESMF_AttributeSetAttPackDistGridI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridI4_N()"
subroutine ESMF_AttributeSetObjDistGridI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridI8()"
subroutine ESMF_AttributeSetAttPackDistGridI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridI8()"
subroutine ESMF_AttributeSetObjDistGridI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridI8_N()"
subroutine ESMF_AttributeSetAttPackDistGridI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridI8_N()"
subroutine ESMF_AttributeSetObjDistGridI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridCH()"
subroutine ESMF_AttributeSetAttPackDistGridCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridCH()"
subroutine ESMF_AttributeSetObjDistGridCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridCH_N()"
subroutine ESMF_AttributeSetAttPackDistGridCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridCH_N()"
subroutine ESMF_AttributeSetObjDistGridCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridLG()"
subroutine ESMF_AttributeSetAttPackDistGridLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridLG()"
subroutine ESMF_AttributeSetObjDistGridLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackDistGridLG_N()"
subroutine ESMF_AttributeSetAttPackDistGridLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackDistGridLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjDistGridLG_N()"
subroutine ESMF_AttributeSetObjDistGridLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjDistGridLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldR4()"
subroutine ESMF_AttributeSetAttPackFieldR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldR4()"
subroutine ESMF_AttributeSetObjFieldR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldR4_N()"
subroutine ESMF_AttributeSetAttPackFieldR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldR4_N()"
subroutine ESMF_AttributeSetObjFieldR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldR8()"
subroutine ESMF_AttributeSetAttPackFieldR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldR8()"
subroutine ESMF_AttributeSetObjFieldR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldR8_N()"
subroutine ESMF_AttributeSetAttPackFieldR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldR8_N()"
subroutine ESMF_AttributeSetObjFieldR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldI4()"
subroutine ESMF_AttributeSetAttPackFieldI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldI4()"
subroutine ESMF_AttributeSetObjFieldI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldI4_N()"
subroutine ESMF_AttributeSetAttPackFieldI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldI4_N()"
subroutine ESMF_AttributeSetObjFieldI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldI8()"
subroutine ESMF_AttributeSetAttPackFieldI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldI8()"
subroutine ESMF_AttributeSetObjFieldI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldI8_N()"
subroutine ESMF_AttributeSetAttPackFieldI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldI8_N()"
subroutine ESMF_AttributeSetObjFieldI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldCH()"
subroutine ESMF_AttributeSetAttPackFieldCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldCH()"
subroutine ESMF_AttributeSetObjFieldCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldCH_N()"
subroutine ESMF_AttributeSetAttPackFieldCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldCH_N()"
subroutine ESMF_AttributeSetObjFieldCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldLG()"
subroutine ESMF_AttributeSetAttPackFieldLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldLG()"
subroutine ESMF_AttributeSetObjFieldLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldLG_N()"
subroutine ESMF_AttributeSetAttPackFieldLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldLG_N()"
subroutine ESMF_AttributeSetObjFieldLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleR4()"
subroutine ESMF_AttributeSetAttPackFieldBundleR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleR4()"
subroutine ESMF_AttributeSetObjFieldBundleR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleR4_N()"
subroutine ESMF_AttributeSetAttPackFieldBundleR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleR4_N()"
subroutine ESMF_AttributeSetObjFieldBundleR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleR8()"
subroutine ESMF_AttributeSetAttPackFieldBundleR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleR8()"
subroutine ESMF_AttributeSetObjFieldBundleR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleR8_N()"
subroutine ESMF_AttributeSetAttPackFieldBundleR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleR8_N()"
subroutine ESMF_AttributeSetObjFieldBundleR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleI4()"
subroutine ESMF_AttributeSetAttPackFieldBundleI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleI4()"
subroutine ESMF_AttributeSetObjFieldBundleI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleI4_N()"
subroutine ESMF_AttributeSetAttPackFieldBundleI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleI4_N()"
subroutine ESMF_AttributeSetObjFieldBundleI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleI8()"
subroutine ESMF_AttributeSetAttPackFieldBundleI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleI8()"
subroutine ESMF_AttributeSetObjFieldBundleI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleI8_N()"
subroutine ESMF_AttributeSetAttPackFieldBundleI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleI8_N()"
subroutine ESMF_AttributeSetObjFieldBundleI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleCH()"
subroutine ESMF_AttributeSetAttPackFieldBundleCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleCH()"
subroutine ESMF_AttributeSetObjFieldBundleCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleCH_N()"
subroutine ESMF_AttributeSetAttPackFieldBundleCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleCH_N()"
subroutine ESMF_AttributeSetObjFieldBundleCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleLG()"
subroutine ESMF_AttributeSetAttPackFieldBundleLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleLG()"
subroutine ESMF_AttributeSetObjFieldBundleLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackFieldBundleLG_N()"
subroutine ESMF_AttributeSetAttPackFieldBundleLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackFieldBundleLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjFieldBundleLG_N()"
subroutine ESMF_AttributeSetObjFieldBundleLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjFieldBundleLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridR4()"
subroutine ESMF_AttributeSetAttPackGridR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridR4()"
subroutine ESMF_AttributeSetObjGridR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridR4_N()"
subroutine ESMF_AttributeSetAttPackGridR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridR4_N()"
subroutine ESMF_AttributeSetObjGridR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridR8()"
subroutine ESMF_AttributeSetAttPackGridR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridR8()"
subroutine ESMF_AttributeSetObjGridR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridR8_N()"
subroutine ESMF_AttributeSetAttPackGridR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridR8_N()"
subroutine ESMF_AttributeSetObjGridR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridI4()"
subroutine ESMF_AttributeSetAttPackGridI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridI4()"
subroutine ESMF_AttributeSetObjGridI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridI4_N()"
subroutine ESMF_AttributeSetAttPackGridI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridI4_N()"
subroutine ESMF_AttributeSetObjGridI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridI8()"
subroutine ESMF_AttributeSetAttPackGridI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridI8()"
subroutine ESMF_AttributeSetObjGridI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridI8_N()"
subroutine ESMF_AttributeSetAttPackGridI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridI8_N()"
subroutine ESMF_AttributeSetObjGridI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCH()"
subroutine ESMF_AttributeSetAttPackGridCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCH()"
subroutine ESMF_AttributeSetObjGridCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridCH_N()"
subroutine ESMF_AttributeSetAttPackGridCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridCH_N()"
subroutine ESMF_AttributeSetObjGridCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridLG()"
subroutine ESMF_AttributeSetAttPackGridLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridLG()"
subroutine ESMF_AttributeSetObjGridLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackGridLG_N()"
subroutine ESMF_AttributeSetAttPackGridLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackGridLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjGridLG_N()"
subroutine ESMF_AttributeSetObjGridLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjGridLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateR4()"
subroutine ESMF_AttributeSetAttPackStateR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateR4()"
subroutine ESMF_AttributeSetObjStateR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateR4_N()"
subroutine ESMF_AttributeSetAttPackStateR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateR4_N()"
subroutine ESMF_AttributeSetObjStateR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateR8()"
subroutine ESMF_AttributeSetAttPackStateR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateR8()"
subroutine ESMF_AttributeSetObjStateR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateR8_N()"
subroutine ESMF_AttributeSetAttPackStateR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateR8_N()"
subroutine ESMF_AttributeSetObjStateR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateI4()"
subroutine ESMF_AttributeSetAttPackStateI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateI4()"
subroutine ESMF_AttributeSetObjStateI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateI4_N()"
subroutine ESMF_AttributeSetAttPackStateI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateI4_N()"
subroutine ESMF_AttributeSetObjStateI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateI8()"
subroutine ESMF_AttributeSetAttPackStateI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateI8()"
subroutine ESMF_AttributeSetObjStateI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateI8_N()"
subroutine ESMF_AttributeSetAttPackStateI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateI8_N()"
subroutine ESMF_AttributeSetObjStateI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateCH()"
subroutine ESMF_AttributeSetAttPackStateCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateCH()"
subroutine ESMF_AttributeSetObjStateCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateCH_N()"
subroutine ESMF_AttributeSetAttPackStateCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateCH_N()"
subroutine ESMF_AttributeSetObjStateCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateLG()"
subroutine ESMF_AttributeSetAttPackStateLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateLG()"
subroutine ESMF_AttributeSetObjStateLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackStateLG_N()"
subroutine ESMF_AttributeSetAttPackStateLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackStateLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjStateLG_N()"
subroutine ESMF_AttributeSetObjStateLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjStateLG_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamR4()"
subroutine ESMF_AttributeSetAttPackLocStreamR4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamR4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamR4()"
subroutine ESMF_AttributeSetObjLocStreamR4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamR4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamR4_N()"
subroutine ESMF_AttributeSetAttPackLocStreamR4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamR4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamR4_N()"
subroutine ESMF_AttributeSetObjLocStreamR4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamR4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamR8()"
subroutine ESMF_AttributeSetAttPackLocStreamR8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamR8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamR8()"
subroutine ESMF_AttributeSetObjLocStreamR8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamR8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamR8_N()"
subroutine ESMF_AttributeSetAttPackLocStreamR8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamR8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamR8_N()"
subroutine ESMF_AttributeSetObjLocStreamR8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamR8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamI4()"
subroutine ESMF_AttributeSetAttPackLocStreamI4(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamI4

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamI4()"
subroutine ESMF_AttributeSetObjLocStreamI4(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamI4


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamI4_N()"
subroutine ESMF_AttributeSetAttPackLocStreamI4_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamI4_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamI4_N()"
subroutine ESMF_AttributeSetObjLocStreamI4_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamI4_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamI8()"
subroutine ESMF_AttributeSetAttPackLocStreamI8(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamI8

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamI8()"
subroutine ESMF_AttributeSetObjLocStreamI8(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamI8


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamI8_N()"
subroutine ESMF_AttributeSetAttPackLocStreamI8_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamI8_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamI8_N()"
subroutine ESMF_AttributeSetObjLocStreamI8_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamI8_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamCH()"
subroutine ESMF_AttributeSetAttPackLocStreamCH(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamCH

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamCH()"
subroutine ESMF_AttributeSetObjLocStreamCH(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamCH


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamCH_N()"
subroutine ESMF_AttributeSetAttPackLocStreamCH_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamCH_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamCH_N()"
subroutine ESMF_AttributeSetObjLocStreamCH_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamCH_N


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamLG()"
subroutine ESMF_AttributeSetAttPackLocStreamLG(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamLG

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamLG()"
subroutine ESMF_AttributeSetObjLocStreamLG(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamLG


#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetAttPackLocStreamLG_N()"
subroutine ESMF_AttributeSetAttPackLocStreamLG_N(target, name, value, attpack, keywordEnforcer, itemcount, rc)
  ! 39.11.35/37 - Target is a NOOP only the attpack is used; itemcount is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(attpack%info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetAttPackLocStreamLG_N

!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeSetObjLocStreamLG_N()"
subroutine ESMF_AttributeSetObjLocStreamLG_N(target, name, value, keywordEnforcer, convention, purpose, attPackInstanceName, itemcount, rc)
  ! 39.11.38/40 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(in) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  integer, intent(in), optional :: itemcount
  integer, intent(inout), optional :: rc

  integer :: len_key, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Set(info, key, value, force=ESMF_ATTR_DEFAULT_FORCE, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeSetObjLocStreamLG_N

!==============================================================================
! ESMF_AttributeGet ===========================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayR4()"
subroutine ESMF_AttributeGetAttPackArrayR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayR4()"
subroutine ESMF_AttributeGetObjArrayR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayR8()"
subroutine ESMF_AttributeGetAttPackArrayR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayR8()"
subroutine ESMF_AttributeGetObjArrayR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayI4()"
subroutine ESMF_AttributeGetAttPackArrayI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayI4()"
subroutine ESMF_AttributeGetObjArrayI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayI8()"
subroutine ESMF_AttributeGetAttPackArrayI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayI8()"
subroutine ESMF_AttributeGetObjArrayI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayCH()"
subroutine ESMF_AttributeGetAttPackArrayCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayCH()"
subroutine ESMF_AttributeGetObjArrayCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayLG()"
subroutine ESMF_AttributeGetAttPackArrayLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayLG()"
subroutine ESMF_AttributeGetObjArrayLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundleR4()"
subroutine ESMF_AttributeGetAttPackArrayBundleR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundleR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayBundleR4()"
subroutine ESMF_AttributeGetObjArrayBundleR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayBundleR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundleR8()"
subroutine ESMF_AttributeGetAttPackArrayBundleR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundleR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayBundleR8()"
subroutine ESMF_AttributeGetObjArrayBundleR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayBundleR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundleI4()"
subroutine ESMF_AttributeGetAttPackArrayBundleI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundleI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayBundleI4()"
subroutine ESMF_AttributeGetObjArrayBundleI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayBundleI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundleI8()"
subroutine ESMF_AttributeGetAttPackArrayBundleI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundleI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayBundleI8()"
subroutine ESMF_AttributeGetObjArrayBundleI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayBundleI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundleCH()"
subroutine ESMF_AttributeGetAttPackArrayBundleCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundleCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayBundleCH()"
subroutine ESMF_AttributeGetObjArrayBundleCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayBundleCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundleLG()"
subroutine ESMF_AttributeGetAttPackArrayBundleLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundleLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjArrayBundleLG()"
subroutine ESMF_AttributeGetObjArrayBundleLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjArrayBundleLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplCompR4()"
subroutine ESMF_AttributeGetAttPackCplCompR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjCplCompR4()"
subroutine ESMF_AttributeGetObjCplCompR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjCplCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplCompR8()"
subroutine ESMF_AttributeGetAttPackCplCompR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjCplCompR8()"
subroutine ESMF_AttributeGetObjCplCompR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjCplCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplCompI4()"
subroutine ESMF_AttributeGetAttPackCplCompI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjCplCompI4()"
subroutine ESMF_AttributeGetObjCplCompI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjCplCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplCompI8()"
subroutine ESMF_AttributeGetAttPackCplCompI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjCplCompI8()"
subroutine ESMF_AttributeGetObjCplCompI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjCplCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplCompCH()"
subroutine ESMF_AttributeGetAttPackCplCompCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjCplCompCH()"
subroutine ESMF_AttributeGetObjCplCompCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjCplCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplCompLG()"
subroutine ESMF_AttributeGetAttPackCplCompLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjCplCompLG()"
subroutine ESMF_AttributeGetObjCplCompLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjCplCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCompR4()"
subroutine ESMF_AttributeGetAttPackGridCompR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCompR4()"
subroutine ESMF_AttributeGetObjGridCompR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCompR8()"
subroutine ESMF_AttributeGetAttPackGridCompR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCompR8()"
subroutine ESMF_AttributeGetObjGridCompR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCompI4()"
subroutine ESMF_AttributeGetAttPackGridCompI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCompI4()"
subroutine ESMF_AttributeGetObjGridCompI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCompI8()"
subroutine ESMF_AttributeGetAttPackGridCompI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCompI8()"
subroutine ESMF_AttributeGetObjGridCompI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCompCH()"
subroutine ESMF_AttributeGetAttPackGridCompCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCompCH()"
subroutine ESMF_AttributeGetObjGridCompCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCompLG()"
subroutine ESMF_AttributeGetAttPackGridCompLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCompLG()"
subroutine ESMF_AttributeGetObjGridCompLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciCompR4()"
subroutine ESMF_AttributeGetAttPackSciCompR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjSciCompR4()"
subroutine ESMF_AttributeGetObjSciCompR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjSciCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciCompR8()"
subroutine ESMF_AttributeGetAttPackSciCompR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjSciCompR8()"
subroutine ESMF_AttributeGetObjSciCompR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjSciCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciCompI4()"
subroutine ESMF_AttributeGetAttPackSciCompI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjSciCompI4()"
subroutine ESMF_AttributeGetObjSciCompI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjSciCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciCompI8()"
subroutine ESMF_AttributeGetAttPackSciCompI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjSciCompI8()"
subroutine ESMF_AttributeGetObjSciCompI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjSciCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciCompCH()"
subroutine ESMF_AttributeGetAttPackSciCompCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjSciCompCH()"
subroutine ESMF_AttributeGetObjSciCompCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjSciCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciCompLG()"
subroutine ESMF_AttributeGetAttPackSciCompLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjSciCompLG()"
subroutine ESMF_AttributeGetObjSciCompLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjSciCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGridR4()"
subroutine ESMF_AttributeGetAttPackDistGridR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGridR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjDistGridR4()"
subroutine ESMF_AttributeGetObjDistGridR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjDistGridR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGridR8()"
subroutine ESMF_AttributeGetAttPackDistGridR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGridR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjDistGridR8()"
subroutine ESMF_AttributeGetObjDistGridR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjDistGridR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGridI4()"
subroutine ESMF_AttributeGetAttPackDistGridI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGridI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjDistGridI4()"
subroutine ESMF_AttributeGetObjDistGridI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjDistGridI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGridI8()"
subroutine ESMF_AttributeGetAttPackDistGridI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGridI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjDistGridI8()"
subroutine ESMF_AttributeGetObjDistGridI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjDistGridI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGridCH()"
subroutine ESMF_AttributeGetAttPackDistGridCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGridCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjDistGridCH()"
subroutine ESMF_AttributeGetObjDistGridCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjDistGridCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGridLG()"
subroutine ESMF_AttributeGetAttPackDistGridLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGridLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjDistGridLG()"
subroutine ESMF_AttributeGetObjDistGridLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjDistGridLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldR4()"
subroutine ESMF_AttributeGetAttPackFieldR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldR4()"
subroutine ESMF_AttributeGetObjFieldR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldR8()"
subroutine ESMF_AttributeGetAttPackFieldR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldR8()"
subroutine ESMF_AttributeGetObjFieldR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldI4()"
subroutine ESMF_AttributeGetAttPackFieldI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldI4()"
subroutine ESMF_AttributeGetObjFieldI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldI8()"
subroutine ESMF_AttributeGetAttPackFieldI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldI8()"
subroutine ESMF_AttributeGetObjFieldI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldCH()"
subroutine ESMF_AttributeGetAttPackFieldCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldCH()"
subroutine ESMF_AttributeGetObjFieldCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldLG()"
subroutine ESMF_AttributeGetAttPackFieldLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldLG()"
subroutine ESMF_AttributeGetObjFieldLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundleR4()"
subroutine ESMF_AttributeGetAttPackFieldBundleR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundleR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldBundleR4()"
subroutine ESMF_AttributeGetObjFieldBundleR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldBundleR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundleR8()"
subroutine ESMF_AttributeGetAttPackFieldBundleR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundleR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldBundleR8()"
subroutine ESMF_AttributeGetObjFieldBundleR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldBundleR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundleI4()"
subroutine ESMF_AttributeGetAttPackFieldBundleI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundleI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldBundleI4()"
subroutine ESMF_AttributeGetObjFieldBundleI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldBundleI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundleI8()"
subroutine ESMF_AttributeGetAttPackFieldBundleI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundleI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldBundleI8()"
subroutine ESMF_AttributeGetObjFieldBundleI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldBundleI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundleCH()"
subroutine ESMF_AttributeGetAttPackFieldBundleCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundleCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldBundleCH()"
subroutine ESMF_AttributeGetObjFieldBundleCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldBundleCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundleLG()"
subroutine ESMF_AttributeGetAttPackFieldBundleLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundleLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjFieldBundleLG()"
subroutine ESMF_AttributeGetObjFieldBundleLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjFieldBundleLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridR4()"
subroutine ESMF_AttributeGetAttPackGridR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridR4()"
subroutine ESMF_AttributeGetObjGridR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridR8()"
subroutine ESMF_AttributeGetAttPackGridR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridR8()"
subroutine ESMF_AttributeGetObjGridR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridI4()"
subroutine ESMF_AttributeGetAttPackGridI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridI4()"
subroutine ESMF_AttributeGetObjGridI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridI8()"
subroutine ESMF_AttributeGetAttPackGridI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridI8()"
subroutine ESMF_AttributeGetObjGridI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridCH()"
subroutine ESMF_AttributeGetAttPackGridCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridCH()"
subroutine ESMF_AttributeGetObjGridCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridLG()"
subroutine ESMF_AttributeGetAttPackGridLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjGridLG()"
subroutine ESMF_AttributeGetObjGridLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjGridLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackStateR4()"
subroutine ESMF_AttributeGetAttPackStateR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackStateR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjStateR4()"
subroutine ESMF_AttributeGetObjStateR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjStateR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackStateR8()"
subroutine ESMF_AttributeGetAttPackStateR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackStateR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjStateR8()"
subroutine ESMF_AttributeGetObjStateR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjStateR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackStateI4()"
subroutine ESMF_AttributeGetAttPackStateI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackStateI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjStateI4()"
subroutine ESMF_AttributeGetObjStateI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjStateI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackStateI8()"
subroutine ESMF_AttributeGetAttPackStateI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackStateI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjStateI8()"
subroutine ESMF_AttributeGetObjStateI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjStateI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackStateCH()"
subroutine ESMF_AttributeGetAttPackStateCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackStateCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjStateCH()"
subroutine ESMF_AttributeGetObjStateCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjStateCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackStateLG()"
subroutine ESMF_AttributeGetAttPackStateLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackStateLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjStateLG()"
subroutine ESMF_AttributeGetObjStateLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjStateLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStreamR4()"
subroutine ESMF_AttributeGetAttPackLocStreamR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStreamR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjLocStreamR4()"
subroutine ESMF_AttributeGetObjLocStreamR4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjLocStreamR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStreamR8()"
subroutine ESMF_AttributeGetAttPackLocStreamR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStreamR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjLocStreamR8()"
subroutine ESMF_AttributeGetObjLocStreamR8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjLocStreamR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStreamI4()"
subroutine ESMF_AttributeGetAttPackLocStreamI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStreamI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjLocStreamI4()"
subroutine ESMF_AttributeGetObjLocStreamI4(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjLocStreamI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStreamI8()"
subroutine ESMF_AttributeGetAttPackLocStreamI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStreamI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjLocStreamI8()"
subroutine ESMF_AttributeGetObjLocStreamI8(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjLocStreamI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStreamCH()"
subroutine ESMF_AttributeGetAttPackLocStreamCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStreamCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjLocStreamCH()"
subroutine ESMF_AttributeGetObjLocStreamCH(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjLocStreamCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStreamLG()"
subroutine ESMF_AttributeGetAttPackLocStreamLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, isPresent, rc)
  ! 39.11.7
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(attpack%info, key, attnestflag=attnestflag, isPointer=.true., rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(attpack%info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStreamLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetObjLocStreamLG()"
subroutine ESMF_AttributeGetObjLocStreamLG(target, name, value, keywordEnforcer, defaultvalue, convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
  ! 39.11.11 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, intent(in), optional :: defaultvalue
  character(len=*), optional, intent(in) :: convention
  character(len=*), optional, intent(in) :: purpose
  character(len=*), optional, intent(in) :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  logical :: should_get
  character(:), allocatable :: key
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = ESMF_Info2IsPresent(info, key, isPointer=.true., attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  should_get = .true.
  if (present(isPresent)) then
    if (.not. isPresent) should_get = .false.
  endif

  if (should_get) then
    call ESMF_Info2Get(info, key, value, default=defaultvalue, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetObjLocStreamLG

!==============================================================================
! ESMF_AttributeGet (Lists) ===================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayR4()"
subroutine ESMF_AttributeGetListAttPackArrayR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayR4()"
subroutine ESMF_AttributeGetListObjArrayR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayR8()"
subroutine ESMF_AttributeGetListAttPackArrayR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayR8()"
subroutine ESMF_AttributeGetListObjArrayR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayI4()"
subroutine ESMF_AttributeGetListAttPackArrayI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayI4()"
subroutine ESMF_AttributeGetListObjArrayI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayI8()"
subroutine ESMF_AttributeGetListAttPackArrayI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayI8()"
subroutine ESMF_AttributeGetListObjArrayI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayCH()"
subroutine ESMF_AttributeGetListAttPackArrayCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayCH()"
subroutine ESMF_AttributeGetListObjArrayCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayLG()"
subroutine ESMF_AttributeGetListAttPackArrayLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayLG()"
subroutine ESMF_AttributeGetListObjArrayLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayBundleR4()"
subroutine ESMF_AttributeGetListAttPackArrayBundleR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayBundleR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayBundleR4()"
subroutine ESMF_AttributeGetListObjArrayBundleR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayBundleR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayBundleR8()"
subroutine ESMF_AttributeGetListAttPackArrayBundleR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayBundleR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayBundleR8()"
subroutine ESMF_AttributeGetListObjArrayBundleR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayBundleR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayBundleI4()"
subroutine ESMF_AttributeGetListAttPackArrayBundleI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayBundleI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayBundleI4()"
subroutine ESMF_AttributeGetListObjArrayBundleI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayBundleI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayBundleI8()"
subroutine ESMF_AttributeGetListAttPackArrayBundleI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayBundleI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayBundleI8()"
subroutine ESMF_AttributeGetListObjArrayBundleI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayBundleI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayBundleCH()"
subroutine ESMF_AttributeGetListAttPackArrayBundleCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayBundleCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayBundleCH()"
subroutine ESMF_AttributeGetListObjArrayBundleCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayBundleCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackArrayBundleLG()"
subroutine ESMF_AttributeGetListAttPackArrayBundleLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackArrayBundleLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjArrayBundleLG()"
subroutine ESMF_AttributeGetListObjArrayBundleLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjArrayBundleLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackCplCompR4()"
subroutine ESMF_AttributeGetListAttPackCplCompR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackCplCompR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjCplCompR4()"
subroutine ESMF_AttributeGetListObjCplCompR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjCplCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackCplCompR8()"
subroutine ESMF_AttributeGetListAttPackCplCompR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackCplCompR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjCplCompR8()"
subroutine ESMF_AttributeGetListObjCplCompR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjCplCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackCplCompI4()"
subroutine ESMF_AttributeGetListAttPackCplCompI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackCplCompI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjCplCompI4()"
subroutine ESMF_AttributeGetListObjCplCompI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjCplCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackCplCompI8()"
subroutine ESMF_AttributeGetListAttPackCplCompI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackCplCompI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjCplCompI8()"
subroutine ESMF_AttributeGetListObjCplCompI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjCplCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackCplCompCH()"
subroutine ESMF_AttributeGetListAttPackCplCompCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackCplCompCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjCplCompCH()"
subroutine ESMF_AttributeGetListObjCplCompCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjCplCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackCplCompLG()"
subroutine ESMF_AttributeGetListAttPackCplCompLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackCplCompLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjCplCompLG()"
subroutine ESMF_AttributeGetListObjCplCompLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjCplCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCompR4()"
subroutine ESMF_AttributeGetListAttPackGridCompR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCompR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCompR4()"
subroutine ESMF_AttributeGetListObjGridCompR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCompR8()"
subroutine ESMF_AttributeGetListAttPackGridCompR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCompR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCompR8()"
subroutine ESMF_AttributeGetListObjGridCompR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCompI4()"
subroutine ESMF_AttributeGetListAttPackGridCompI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCompI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCompI4()"
subroutine ESMF_AttributeGetListObjGridCompI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCompI8()"
subroutine ESMF_AttributeGetListAttPackGridCompI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCompI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCompI8()"
subroutine ESMF_AttributeGetListObjGridCompI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCompCH()"
subroutine ESMF_AttributeGetListAttPackGridCompCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCompCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCompCH()"
subroutine ESMF_AttributeGetListObjGridCompCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCompLG()"
subroutine ESMF_AttributeGetListAttPackGridCompLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCompLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCompLG()"
subroutine ESMF_AttributeGetListObjGridCompLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackSciCompR4()"
subroutine ESMF_AttributeGetListAttPackSciCompR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackSciCompR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjSciCompR4()"
subroutine ESMF_AttributeGetListObjSciCompR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjSciCompR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackSciCompR8()"
subroutine ESMF_AttributeGetListAttPackSciCompR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackSciCompR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjSciCompR8()"
subroutine ESMF_AttributeGetListObjSciCompR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjSciCompR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackSciCompI4()"
subroutine ESMF_AttributeGetListAttPackSciCompI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackSciCompI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjSciCompI4()"
subroutine ESMF_AttributeGetListObjSciCompI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjSciCompI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackSciCompI8()"
subroutine ESMF_AttributeGetListAttPackSciCompI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackSciCompI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjSciCompI8()"
subroutine ESMF_AttributeGetListObjSciCompI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjSciCompI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackSciCompCH()"
subroutine ESMF_AttributeGetListAttPackSciCompCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackSciCompCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjSciCompCH()"
subroutine ESMF_AttributeGetListObjSciCompCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjSciCompCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackSciCompLG()"
subroutine ESMF_AttributeGetListAttPackSciCompLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackSciCompLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjSciCompLG()"
subroutine ESMF_AttributeGetListObjSciCompLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjSciCompLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackDistGridR4()"
subroutine ESMF_AttributeGetListAttPackDistGridR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackDistGridR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjDistGridR4()"
subroutine ESMF_AttributeGetListObjDistGridR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjDistGridR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackDistGridR8()"
subroutine ESMF_AttributeGetListAttPackDistGridR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackDistGridR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjDistGridR8()"
subroutine ESMF_AttributeGetListObjDistGridR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjDistGridR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackDistGridI4()"
subroutine ESMF_AttributeGetListAttPackDistGridI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackDistGridI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjDistGridI4()"
subroutine ESMF_AttributeGetListObjDistGridI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjDistGridI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackDistGridI8()"
subroutine ESMF_AttributeGetListAttPackDistGridI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackDistGridI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjDistGridI8()"
subroutine ESMF_AttributeGetListObjDistGridI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjDistGridI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackDistGridCH()"
subroutine ESMF_AttributeGetListAttPackDistGridCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackDistGridCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjDistGridCH()"
subroutine ESMF_AttributeGetListObjDistGridCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjDistGridCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackDistGridLG()"
subroutine ESMF_AttributeGetListAttPackDistGridLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackDistGridLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjDistGridLG()"
subroutine ESMF_AttributeGetListObjDistGridLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjDistGridLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldR4()"
subroutine ESMF_AttributeGetListAttPackFieldR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldR4()"
subroutine ESMF_AttributeGetListObjFieldR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldR8()"
subroutine ESMF_AttributeGetListAttPackFieldR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldR8()"
subroutine ESMF_AttributeGetListObjFieldR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldI4()"
subroutine ESMF_AttributeGetListAttPackFieldI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldI4()"
subroutine ESMF_AttributeGetListObjFieldI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldI8()"
subroutine ESMF_AttributeGetListAttPackFieldI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldI8()"
subroutine ESMF_AttributeGetListObjFieldI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldCH()"
subroutine ESMF_AttributeGetListAttPackFieldCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldCH()"
subroutine ESMF_AttributeGetListObjFieldCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldLG()"
subroutine ESMF_AttributeGetListAttPackFieldLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldLG()"
subroutine ESMF_AttributeGetListObjFieldLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldBundleR4()"
subroutine ESMF_AttributeGetListAttPackFieldBundleR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldBundleR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldBundleR4()"
subroutine ESMF_AttributeGetListObjFieldBundleR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldBundleR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldBundleR8()"
subroutine ESMF_AttributeGetListAttPackFieldBundleR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldBundleR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldBundleR8()"
subroutine ESMF_AttributeGetListObjFieldBundleR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldBundleR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldBundleI4()"
subroutine ESMF_AttributeGetListAttPackFieldBundleI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldBundleI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldBundleI4()"
subroutine ESMF_AttributeGetListObjFieldBundleI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldBundleI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldBundleI8()"
subroutine ESMF_AttributeGetListAttPackFieldBundleI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldBundleI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldBundleI8()"
subroutine ESMF_AttributeGetListObjFieldBundleI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldBundleI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldBundleCH()"
subroutine ESMF_AttributeGetListAttPackFieldBundleCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldBundleCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldBundleCH()"
subroutine ESMF_AttributeGetListObjFieldBundleCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldBundleCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackFieldBundleLG()"
subroutine ESMF_AttributeGetListAttPackFieldBundleLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackFieldBundleLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjFieldBundleLG()"
subroutine ESMF_AttributeGetListObjFieldBundleLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjFieldBundleLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridR4()"
subroutine ESMF_AttributeGetListAttPackGridR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridR4()"
subroutine ESMF_AttributeGetListObjGridR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridR8()"
subroutine ESMF_AttributeGetListAttPackGridR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridR8()"
subroutine ESMF_AttributeGetListObjGridR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridI4()"
subroutine ESMF_AttributeGetListAttPackGridI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridI4()"
subroutine ESMF_AttributeGetListObjGridI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridI8()"
subroutine ESMF_AttributeGetListAttPackGridI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridI8()"
subroutine ESMF_AttributeGetListObjGridI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridCH()"
subroutine ESMF_AttributeGetListAttPackGridCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridCH()"
subroutine ESMF_AttributeGetListObjGridCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackGridLG()"
subroutine ESMF_AttributeGetListAttPackGridLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackGridLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjGridLG()"
subroutine ESMF_AttributeGetListObjGridLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjGridLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackStateR4()"
subroutine ESMF_AttributeGetListAttPackStateR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackStateR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjStateR4()"
subroutine ESMF_AttributeGetListObjStateR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjStateR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackStateR8()"
subroutine ESMF_AttributeGetListAttPackStateR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackStateR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjStateR8()"
subroutine ESMF_AttributeGetListObjStateR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjStateR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackStateI4()"
subroutine ESMF_AttributeGetListAttPackStateI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackStateI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjStateI4()"
subroutine ESMF_AttributeGetListObjStateI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjStateI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackStateI8()"
subroutine ESMF_AttributeGetListAttPackStateI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackStateI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjStateI8()"
subroutine ESMF_AttributeGetListObjStateI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjStateI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackStateCH()"
subroutine ESMF_AttributeGetListAttPackStateCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackStateCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjStateCH()"
subroutine ESMF_AttributeGetListObjStateCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjStateCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackStateLG()"
subroutine ESMF_AttributeGetListAttPackStateLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackStateLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjStateLG()"
subroutine ESMF_AttributeGetListObjStateLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjStateLG

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackLocStreamR4()"
subroutine ESMF_AttributeGetListAttPackLocStreamR4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackLocStreamR4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjLocStreamR4()"
subroutine ESMF_AttributeGetListObjLocStreamR4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjLocStreamR4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackLocStreamR8()"
subroutine ESMF_AttributeGetListAttPackLocStreamR8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  real(ESMF_KIND_R8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackLocStreamR8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjLocStreamR8()"
subroutine ESMF_AttributeGetListObjLocStreamR8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
  real(ESMF_KIND_R8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjLocStreamR8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackLocStreamI4()"
subroutine ESMF_AttributeGetListAttPackLocStreamI4(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I4), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackLocStreamI4
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjLocStreamI4()"
subroutine ESMF_AttributeGetListObjLocStreamI4(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I4), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjLocStreamI4

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackLocStreamI8()"
subroutine ESMF_AttributeGetListAttPackLocStreamI8(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  integer(ESMF_KIND_I8), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackLocStreamI8
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjLocStreamI8()"
subroutine ESMF_AttributeGetListObjLocStreamI8(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
  integer(ESMF_KIND_I8), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjLocStreamI8

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackLocStreamCH()"
subroutine ESMF_AttributeGetListAttPackLocStreamCH(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  character(len=*), dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackLocStreamCH
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjLocStreamCH()"
subroutine ESMF_AttributeGetListObjLocStreamCH(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  character(len=*), dimension(:), intent(out) :: valueList
  character(len=*), dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjLocStreamCH

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListAttPackLocStreamLG()"
subroutine ESMF_AttributeGetListAttPackLocStreamLG(target, name, attpack, value, keywordEnforcer, defaultvalue, attnestflag, itemcount, isPresent, rc)
  ! 39.11.9
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  logical, dimension(:), allocatable, intent(out) :: value
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  logical, dimension(:), intent(in), optional :: defaultvalue
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(attpack%info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    call ESMF_Info2Get(attpack%info, key, value, nelements=nelements, attnestflag=attnestflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalue)) then
      if (size(defaultvalue) /= size(value)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalue) /= size(value)", ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalue)
        value(ii) = defaultvalue(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalue)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListAttPackLocStreamLG
!==============================================================================
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetListObjLocStreamLG()"
subroutine ESMF_AttributeGetListObjLocStreamLG(target, name, valueList, defaultvalueList, convention, purpose, attPackInstanceName, attnestflag, itemcount, isPresent, rc)
  ! 39.11.13 - attPackInstanceName is NOOP
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  logical, dimension(:), intent(out) :: valueList
  logical, dimension(:), intent(in), optional :: defaultvalueList
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(out), optional :: itemcount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE, ii, nelements
  logical :: local_isPresent
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  local_isPresent = ESMF_Info2IsPresent(info, key, isPointer=.false., attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) isPresent = local_isPresent

  if (local_isPresent) then
    !tdk:todo: enable to work with character arrays


    if (present(itemcount)) itemcount = nelements
  else
    if (present(defaultvalueList)) then
      if (size(defaultvalueList) /= size(valueList)) then
        if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="size(defaultvalueList) /= size(valueList)", &
         ESMF_CONTEXT, rcToReturn=rc)) return
      endif
      do ii=1,size(defaultvalueList)
        valueList(ii) = defaultvalueList(ii)
      enddo
      if (present(itemcount)) itemcount = size(defaultvalueList)
    else
      if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg="The key '"//trim(name)//"' is not present and no default value is provided", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif
  endif

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetListObjLocStreamLG

!==============================================================================
! ESMF_AttributeGet (Inquire) =================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountArray()"
subroutine ESMF_AttributeGetCountArray(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_Array), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountArray
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPArray()"
subroutine ESMF_AttributeGetInfoByNamAPArray(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPArray
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamArray()"
subroutine ESMF_AttributeGetInfoByNamArray(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamArray
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumArray()"
subroutine ESMF_AttributeGetInfoByNumArray(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_Array), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumArray
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArray()"
subroutine ESMF_AttributeGetAttPackArray(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_Array), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArray

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountArrayBundle()"
subroutine ESMF_AttributeGetCountArrayBundle(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_ArrayBundle), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountArrayBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPArrayBundle()"
subroutine ESMF_AttributeGetInfoByNamAPArrayBundle(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPArrayBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamArrayBundle()"
subroutine ESMF_AttributeGetInfoByNamArrayBundle(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamArrayBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumArrayBundle()"
subroutine ESMF_AttributeGetInfoByNumArrayBundle(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_ArrayBundle), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumArrayBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackArrayBundle()"
subroutine ESMF_AttributeGetAttPackArrayBundle(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_ArrayBundle), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackArrayBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountCplComp()"
subroutine ESMF_AttributeGetCountCplComp(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_CplComp), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountCplComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPCplComp()"
subroutine ESMF_AttributeGetInfoByNamAPCplComp(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPCplComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamCplComp()"
subroutine ESMF_AttributeGetInfoByNamCplComp(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamCplComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumCplComp()"
subroutine ESMF_AttributeGetInfoByNumCplComp(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_CplComp), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumCplComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackCplComp()"
subroutine ESMF_AttributeGetAttPackCplComp(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_CplComp), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackCplComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountGridComp()"
subroutine ESMF_AttributeGetCountGridComp(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_GridComp), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountGridComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPGridComp()"
subroutine ESMF_AttributeGetInfoByNamAPGridComp(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPGridComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamGridComp()"
subroutine ESMF_AttributeGetInfoByNamGridComp(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamGridComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumGridComp()"
subroutine ESMF_AttributeGetInfoByNumGridComp(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_GridComp), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumGridComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGridComp()"
subroutine ESMF_AttributeGetAttPackGridComp(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_GridComp), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGridComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountSciComp()"
subroutine ESMF_AttributeGetCountSciComp(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_SciComp), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountSciComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPSciComp()"
subroutine ESMF_AttributeGetInfoByNamAPSciComp(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPSciComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamSciComp()"
subroutine ESMF_AttributeGetInfoByNamSciComp(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamSciComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumSciComp()"
subroutine ESMF_AttributeGetInfoByNumSciComp(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_SciComp), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumSciComp
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackSciComp()"
subroutine ESMF_AttributeGetAttPackSciComp(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_SciComp), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackSciComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountDistGrid()"
subroutine ESMF_AttributeGetCountDistGrid(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_DistGrid), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountDistGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPDistGrid()"
subroutine ESMF_AttributeGetInfoByNamAPDistGrid(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPDistGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamDistGrid()"
subroutine ESMF_AttributeGetInfoByNamDistGrid(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamDistGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumDistGrid()"
subroutine ESMF_AttributeGetInfoByNumDistGrid(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_DistGrid), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumDistGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackDistGrid()"
subroutine ESMF_AttributeGetAttPackDistGrid(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_DistGrid), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackDistGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountField()"
subroutine ESMF_AttributeGetCountField(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_Field), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountField
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPField()"
subroutine ESMF_AttributeGetInfoByNamAPField(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPField
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamField()"
subroutine ESMF_AttributeGetInfoByNamField(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamField
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumField()"
subroutine ESMF_AttributeGetInfoByNumField(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_Field), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumField
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackField()"
subroutine ESMF_AttributeGetAttPackField(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_Field), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackField

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountFieldBundle()"
subroutine ESMF_AttributeGetCountFieldBundle(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_FieldBundle), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountFieldBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPFieldBundle()"
subroutine ESMF_AttributeGetInfoByNamAPFieldBundle(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPFieldBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamFieldBundle()"
subroutine ESMF_AttributeGetInfoByNamFieldBundle(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamFieldBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumFieldBundle()"
subroutine ESMF_AttributeGetInfoByNumFieldBundle(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_FieldBundle), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumFieldBundle
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackFieldBundle()"
subroutine ESMF_AttributeGetAttPackFieldBundle(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_FieldBundle), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackFieldBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountGrid()"
subroutine ESMF_AttributeGetCountGrid(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_Grid), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPGrid()"
subroutine ESMF_AttributeGetInfoByNamAPGrid(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamGrid()"
subroutine ESMF_AttributeGetInfoByNamGrid(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumGrid()"
subroutine ESMF_AttributeGetInfoByNumGrid(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_Grid), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumGrid
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackGrid()"
subroutine ESMF_AttributeGetAttPackGrid(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_Grid), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountState()"
subroutine ESMF_AttributeGetCountState(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_State), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountState
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPState()"
subroutine ESMF_AttributeGetInfoByNamAPState(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPState
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamState()"
subroutine ESMF_AttributeGetInfoByNamState(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamState
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumState()"
subroutine ESMF_AttributeGetInfoByNumState(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_State), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumState
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackState()"
subroutine ESMF_AttributeGetAttPackState(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_State), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackState

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetCountLocStream()"
subroutine ESMF_AttributeGetCountLocStream(target, count, keywordEnforcer, attcountflag, attnestflag, rc)
  ! 39.11.15
  type(ESMF_LocStream), intent(in) :: target
  integer, intent(inout) :: count
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  type(ESMF_Info2) :: info
  type(ESMF_AttGetCountFlag) :: l_attcountflag
  type(ESMF_Inquire) :: einq
  integer :: countSingle, countTotal, attPackCount, localrc=ESMF_FAILURE

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, count=countSingle, countTotal=countTotal, &
    attPackCount=attPackCount, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(attcountflag)) then
    l_attcountflag = attcountflag
  else
    l_attcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE
  end if

  if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTRIBUTE%value) then
    count = countSingle
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_TOTAL%value) then
    count = countTotal
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTPACK%value) then
    count = attPackCount
  else if (l_attcountflag%value==ESMF_ATTGETCOUNT_ATTLINK%value) then
    count = 0
  else
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetCountLocStream
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamAPLocStream()"
subroutine ESMF_AttributeGetInfoByNamAPLocStream(target, name, attpack, keywordEnforcer, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.16
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_AttPack), intent(inout) :: attpack
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, name, localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(attpack%info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(attpack%info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamAPLocStream
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNamLocStream()"
subroutine ESMF_AttributeGetInfoByNamLocStream(target, name, keywordEnforcer, convention, purpose, attPackInstanceName, attnestflag, typekind, itemCount, isPresent, rc)
  ! 39.11.17
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  character(len=*), intent(in), optional :: attPackInstanceName
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  logical, intent(out), optional :: isPresent
  integer, intent(inout), optional :: rc

  integer :: countSingle, localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call format_key(key, name, localrc, convention=convention, purpose=purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (is_present) then
    call ESMF_Info2Inquire(info, key=key, count=itemCount, attnestflag=attnestflag, &
      typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNamLocStream
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetInfoByNumLocStream()"
subroutine ESMF_AttributeGetInfoByNumLocStream(target, attributeIndex, attpack, name, keywordEnforcer, typekind, itemCount, rc)
  ! 39.11.18
  type(ESMF_LocStream), intent(in) :: target
  integer, intent(in) :: attributeIndex
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: name
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
  integer, intent(out), optional :: itemCount
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  type(ESMF_Info2) :: info
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Inquire(info, key=key, count=itemCount, typekind=typekind, &
    idx=attributeIndex, ikey=name, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetInfoByNumLocStream
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeGetAttPackLocStream()"
subroutine ESMF_AttributeGetAttPackLocStream(target, convention, purpose, keywordEnforcer, attPackInstanceName, attpack, attnestflag, isPresent, rc)
  ! 39.11.21
  type(ESMF_LocStream), intent(in) :: target
  character(len=*), intent(in) :: convention
  character(len=*), intent(in) :: purpose
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character (len = *), intent(in), optional :: attPackInstanceName  !tdk: noop, no suppor for attpackinstancename
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag !tdk: noop, are there nested conventions and purposes?
  logical, intent(out), optional :: isPresent
  integer, intent(out), optional :: rc

  integer :: localrc=ESMF_FAILURE
  character(:), allocatable :: key
  logical :: is_present
  type(ESMF_Info2), target, save :: info !tdk:?: is this okay? memory leak?
  type(ESMF_Inquire) :: einq

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  info = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  allocate(character(LEN(TRIM(convention))+LEN(TRIM(purpose))+1)::key)
  key = convention//"/"//purpose
  is_present = ESMF_Info2IsPresent(info, key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(isPresent)) then
    isPresent = is_present
  end if
  if (is_present) then
    if (present(attpack)) then
      attpack%convention = convention
      attpack%purpose = purpose
      attpack%info => info
    end if
  end if

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeGetAttPackLocStream

!==============================================================================
! ESMF_AttributeRemove ========================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackArray()"
subroutine ESMF_AttributeRemoveAttPackArray(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_Array), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackArray









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackArrayBundle()"
subroutine ESMF_AttributeRemoveAttPackArrayBundle(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_ArrayBundle), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackArrayBundle









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackCplComp()"
subroutine ESMF_AttributeRemoveAttPackCplComp(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_CplComp), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackCplComp









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackGridComp()"
subroutine ESMF_AttributeRemoveAttPackGridComp(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_GridComp), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackGridComp









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackSciComp()"
subroutine ESMF_AttributeRemoveAttPackSciComp(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_SciComp), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackSciComp









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackDistGrid()"
subroutine ESMF_AttributeRemoveAttPackDistGrid(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_DistGrid), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackDistGrid









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackField()"
subroutine ESMF_AttributeRemoveAttPackField(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_Field), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackField









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackFieldBundle()"
subroutine ESMF_AttributeRemoveAttPackFieldBundle(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_FieldBundle), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackFieldBundle









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackGrid()"
subroutine ESMF_AttributeRemoveAttPackGrid(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_Grid), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackGrid









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackState()"
subroutine ESMF_AttributeRemoveAttPackState(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_State), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackState









































#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeRemoveAttPackLocStream()"
subroutine ESMF_AttributeRemoveAttPackLocStream(target, keywordEnforcer, name, attpack, attnestflag, rc)
  ! 39.11.33
  type(ESMF_LocStream), intent(inout) :: target
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: name
  type(ESMF_AttPack), intent(inout), optional :: attpack
  type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2), pointer :: p_info
  type(ESMF_Info2), target :: info
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  if (present(attpack)) then
    call validate_attpack(attpack, localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  ! If attpack, use target as info source
  if (present(attpack) .and. present(name)) then
    p_info => attpack%info
  ! If no attpack, use target as info source
  else
    info = einq%GetInfo(target, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    p_info => info
  end if

  ! If a name is provided, use this as the key to remove
  if (present(name)) then
    key = name
  ! Otherwise, plan to remove the whole attpack
  else
    if (.not. present(attpack)) then
      if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="No name or attpack provided. Nothing to remove.", &
        ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Format the key using the conv/purp pulled from the attpack
    call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  call ESMF_Info2Remove(p_info, key, attnestflag=attnestflag, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  deallocate(key)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeRemoveAttPackLocStream









































!==============================================================================
! ESMF_AttributeCopy ==========================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyArray()"
subroutine ESMF_AttributeCopyArray(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_Array), intent(in) :: src
  type(ESMF_Array), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyArray

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyArrayBundle()"
subroutine ESMF_AttributeCopyArrayBundle(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_ArrayBundle), intent(in) :: src
  type(ESMF_ArrayBundle), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyArrayBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyCplComp()"
subroutine ESMF_AttributeCopyCplComp(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_CplComp), intent(in) :: src
  type(ESMF_CplComp), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyCplComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyGridComp()"
subroutine ESMF_AttributeCopyGridComp(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_GridComp), intent(in) :: src
  type(ESMF_GridComp), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyGridComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopySciComp()"
subroutine ESMF_AttributeCopySciComp(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_SciComp), intent(in) :: src
  type(ESMF_SciComp), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopySciComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyDistGrid()"
subroutine ESMF_AttributeCopyDistGrid(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_DistGrid), intent(in) :: src
  type(ESMF_DistGrid), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyDistGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyField()"
subroutine ESMF_AttributeCopyField(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_Field), intent(in) :: src
  type(ESMF_Field), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyField

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyFieldBundle()"
subroutine ESMF_AttributeCopyFieldBundle(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_FieldBundle), intent(in) :: src
  type(ESMF_FieldBundle), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyFieldBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyGrid()"
subroutine ESMF_AttributeCopyGrid(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_Grid), intent(in) :: src
  type(ESMF_Grid), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyState()"
subroutine ESMF_AttributeCopyState(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_State), intent(in) :: src
  type(ESMF_State), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyState

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeCopyLocStream()"
subroutine ESMF_AttributeCopyLocStream(src, dst, keywordEnforcer, rc)
  ! 39.11.6 - attcopy is NOOP
  type(ESMF_LocStream), intent(in) :: src
  type(ESMF_LocStream), intent(inout) :: dst
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, src, localrc)
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, dst, localrc)

  isrc = einq%GetInfo(src, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(dst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call c_info_copyforattribute(isrc%ptr, idst%ptr, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeCopyLocStream

!==============================================================================
! ESMF_AttributeRead ==========================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadArray()"
subroutine ESMF_AttributeReadArray(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadArray

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadArrayBundle()"
subroutine ESMF_AttributeReadArrayBundle(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadArrayBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadCplComp()"
subroutine ESMF_AttributeReadCplComp(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadCplComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadGridComp()"
subroutine ESMF_AttributeReadGridComp(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadGridComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadSciComp()"
subroutine ESMF_AttributeReadSciComp(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadSciComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadDistGrid()"
subroutine ESMF_AttributeReadDistGrid(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadDistGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadField()"
subroutine ESMF_AttributeReadField(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadField

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadFieldBundle()"
subroutine ESMF_AttributeReadFieldBundle(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadFieldBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadGrid()"
subroutine ESMF_AttributeReadGrid(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadState()"
subroutine ESMF_AttributeReadState(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadState

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeReadLocStream()"
subroutine ESMF_AttributeReadLocStream(target, filename, keywordenforcer, rc)
  ! 39.11.32 - removed schemaFileName
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: isrc, idst

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  isrc = ESMF_Info2ReadJSON(filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call ESMF_Info2Destroy(idst, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  idst%ptr = isrc%ptr

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeReadLocStream

!==============================================================================
! ESMF_AttributeWrite =========================================================
!==============================================================================

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteArray()"
subroutine ESMF_AttributeWriteArray(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_Array), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteArray

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteArrayBundle()"
subroutine ESMF_AttributeWriteArrayBundle(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_ArrayBundle), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteArrayBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteCplComp()"
subroutine ESMF_AttributeWriteCplComp(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_CplComp), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteCplComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteGridComp()"
subroutine ESMF_AttributeWriteGridComp(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_GridComp), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteGridComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteSciComp()"
subroutine ESMF_AttributeWriteSciComp(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_SciComp), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_SciCompGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteSciComp

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteDistGrid()"
subroutine ESMF_AttributeWriteDistGrid(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_DistGrid), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteDistGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteField()"
subroutine ESMF_AttributeWriteField(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_Field), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteField

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteFieldBundle()"
subroutine ESMF_AttributeWriteFieldBundle(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_FieldBundle), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteFieldBundle

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteGrid()"
subroutine ESMF_AttributeWriteGrid(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_Grid), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteGrid

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteState()"
subroutine ESMF_AttributeWriteState(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_State), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteState

#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_AttributeWriteLocStream()"
subroutine ESMF_AttributeWriteLocStream(target, filename, keywordenforcer, convention, purpose, rc)
  ! 39.11.42 - removed attwriteflag
  type(ESMF_LocStream), intent(inout) :: target
  character(len=*), intent(in) :: fileName
  type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
  character(len=*), intent(in), optional :: convention
  character(len=*), intent(in), optional :: purpose
  integer, intent(inout), optional :: rc

  integer :: localrc=ESMF_FAILURE
  type(ESMF_Inquire) :: einq
  type(ESMF_Info2) :: info, isrc
  character(:), allocatable :: key

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  ! Check object initialization
  ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit, target, localrc)

  isrc = einq%GetInfo(target, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    call format_key(key, "", localrc, convention=convention, purpose=purpose)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

    info = ESMF_Info2Create(isrc, key, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  else
    info = isrc
  endif

  call ESMF_Info2WriteJSON(info, filename, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (present(convention)) then
    deallocate(key)
    call ESMF_Info2Destroy(info, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return
  endif

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttributeWriteLocStream

subroutine ESMF_AttPackStreamJSON(attpack, output, rc)
  ! Removed flattenPackList, includeUnset, includeLinks
  type(ESMF_AttPack), intent(in) :: attpack
  character(len=*), intent(out) :: output
  integer, intent(inout), optional :: rc

  integer :: localrc
  character(:), allocatable :: c_output, key

  localrc = ESMF_FAILURE
  if (present(rc)) rc = ESMF_RC_NOT_IMPL

  call validate_attpack(attpack, localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  call format_key(key, "", localrc, convention=attpack%convention, purpose=attpack%purpose)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  c_output = ESMF_Info2Dump(attpack%info, key=key, rc=localrc)
  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, ESMF_CONTEXT, rcToReturn=rc)) return

  if (LEN(output) < LEN(c_output)) then
    if (ESMF_LogFoundError(ESMF_RC_ARG_BAD, msg="output buffer length too small", ESMF_CONTEXT, rcToReturn=rc)) return
  endif
  output = c_output

  deallocate(key, c_output)

  if (present(rc)) rc = ESMF_SUCCESS
end subroutine ESMF_AttPackStreamJSON

end module ESMF_AttributeMod  !===============================================