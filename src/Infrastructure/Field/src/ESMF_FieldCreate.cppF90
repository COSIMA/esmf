! $Id: ESMF_FieldCreate.cppF90,v 1.7.2.4 2008/03/12 00:47:39 cdeluca Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2007, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FieldCreate.F90"
!
!     ESMF FieldCreate module
      module ESMF_FieldCreateMod
!
!==============================================================================
!
! This file contains the Field class methods which are automatically
!  generated from macros to handle the type/kind/rank overloading.
!  See ESMF_Field.F90 for non-macroized functions and subroutines.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_TypeKindRankMacros.hcppF90"
#include "ESMF_FieldCreateMacros.h"

!------------------------------------------------------------------------------
! !USES:
      use ESMF_UtilTypesMod
      use ESMF_BaseMod
      use ESMF_LogErrMod
      use ESMF_IOSpecMod
      use ESMF_ArraySpecMod
      use ESMF_LocalArrayMod
      use ESMF_DELayoutMod
      use ESMF_StaggerLocMod
      use ESMF_GridMod
      use ESMF_ArrayMod
      use ESMF_ArrayGetMod
      use ESMF_ArrayCreateMod
      use ESMF_FieldMod
      implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
      private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

      public ESMF_FieldCreate
      public ESMF_FieldSetCommit
 
!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
      character(*), parameter, private :: version = &
      '$Id: ESMF_FieldCreate.cppF90,v 1.7.2.4 2008/03/12 00:47:39 cdeluca Exp $'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================


!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_FieldCreate - Create a new Field with data
!
! !INTERFACE:
      interface ESMF_FieldCreate 
   
! !PRIVATE MEMBER FUNCTIONS:
!
        module procedure ESMF_FieldCreateNew
        module procedure ESMF_FieldCreateFromArray
        TypeKindRankInterfaceMacro(FieldCreateFromDataPtr)

! !DESCRIPTION:
!   This interface provides an entry point for methods that create a complete
!   {\tt ESMF\_Field}.  These method all contain an {\tt ESMF\_Grid} and 
!   {\tt ESMF\_Data}.  The variations allow the user to specify the data 
!   using either a Fortran array or an {\tt ESMF\_Array}.
!    
      end interface
!EOPI

!BOPI 
! !IROUTINE: ESMF_FieldSetCommit - finishes a Field started with FieldCreateEmpty
!
! !INTERFACE:
    interface ESMF_FieldSetCommit

        TypeKindRankInterfaceMacro(FieldSetCommit)

! !DESCRIPTION:
!   This interface finishes a {\tt ESMF\_Field} started with FieldCreateEmpty
!   These methods all take {\tt ESMF\_Grid} and Fortran data pointer as input to
!   fill in the {\tt ESMF\_Field} internals. 

    end interface ESMF_FieldSetCommit
!EOPI

!
!==============================================================================
!
      contains
!
!==============================================================================

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateNew"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a new Field from Grid and ArraySpec

! !INTERFACE:
      ! Private name; call using ESMF_FieldCreate()
      function ESMF_FieldCreateNew(grid, arrayspec, allocflag, staggerloc, &
                                   gridToFieldMap, ungriddedLBound, &
                                   ungriddedUBound, maxHaloLWidth, &
                                   maxHaloUWidth, name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Field) :: ESMF_FieldCreateNew
!
! !ARGUMENTS:
      type(ESMF_Grid) :: grid               
      type(ESMF_ArraySpec), intent(inout) :: arrayspec     
      type(ESMF_AllocFlag), intent(in), optional :: allocflag
      type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
      integer, intent(in), optional :: gridToFieldMap(:)    
      integer, intent(in), optional :: ungriddedLBound(:)
      integer, intent(in), optional :: ungriddedUBound(:)
      integer, intent(in), optional :: maxHaloLWidth(:)
      integer, intent(in), optional :: maxHaloUWidth(:)
      character (len=*), intent(in), optional :: name 
      type(ESMF_IOSpec), intent(in), optional :: iospec 
      integer, intent(out), optional :: rc              
!
! !DESCRIPTION:
!     Create an {\tt ESMF\_Field} and allocate space internally for an
!     {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}.
! 
!     The arguments are:
!     \begin{description}
!     \item [grid] 
!           Pointer to an {\tt ESMF\_Grid} object. 
!     \item [arrayspec]
!           Data type and kind specification. 
!     \item [{[allocflag]}]
!           Whether to allocate space for the array.  See 
!           Section~\ref{opt:allocflag} for possible values.  Default is
!           {\tt ESMF\_ALLOC}.
!     \item [{[staggerloc]}]
!           Stagger location of data in grid cells.  For valid
!           predefined values see Section \ref{sec:opt:staggerloc}.
!           To create a custom stagger location see Section
!           \ref{sec:usage:staggerloc:adv}. The default
!           value is ESMF\_STAGGERLOC\_CENTER.
!     \item [{[gridToFieldMap]}]
!           List with number of elements equal to the @\
!           {\tt grid}'s dimCount.  The list elements map each dimension @\
!           of the {\tt grid} to a dimension in the {\tt farray} by @\
!           specifying the appropriate {\tt farray} dimension index. The default is to @\
!           map all of the {\tt grid}'s dimensions against the lowest dimensions of @\
!           the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!           The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!           to one and smaller than or equal to the {\tt farray} rank. @\
!           It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!           multiple times. The total ungridded dimensions in the {\tt field} @\
!           are the total {\tt farray} dimensions less @\
!           the total (distributed + undistributed) dimensions in @\
!           the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!           stored in the {\t farray}.  Permutations of the order of @\
!           dimensions are handled via individual communication methods.  For example, @\
!           an undistributed dimension can be remapped to a distributed dimension @\
!           as part of the ESMF\_ ArrayRedist() operation. @\
!     \item [{[ungriddedLBound]}]
!           Lower bounds of the ungridded dimensions of the {\tt field}. @\
!           The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!           dimensions in the {\tt field}.  All ungridded dimensions of the @\
!           {\tt field} are also undistributed. If neither ungriddedLBounds or @\
!           ungriddedUBounds are specified, the ungriddedLBound defaults to 1, @\
!           and the ungriddedUBound defaults to the size of the dimension. @\
!           If either ungriddedLBounds OR ungriddedUBounds are specified, the @\
!           other will be calculated.  If BOTH are specified the values are checked @\
!           for consistency.  Note that the the ordering of @\
!           these ungridded dimensions is the same as their order in the {\tt farray}. @\
!           Note also that the bounds for undistributed dimensions included in the {\tt grid} are set @\
!           in the {\tt grid}. @\
!     \item [{[ungriddedUBound]}]
!           Upper bounds of the ungridded dimensions of the {\tt field}. @\
!           The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!           dimensions in the {\tt field}.  All ungridded dimensions of the @\
!           {\tt field} are also undistributed. If neither ungriddedLBounds or @\
!           ungriddedUBounds are specified, the ungriddedLBound defaults to 1, @\
!           and the ungriddedUBound defaults to the size of the dimension. @\
!           If either ungriddedLBounds OR ungriddedUBounds are specified, the @\
!           other will be calculated.  If BOTH are specified the values are checked @\
!           for consistency.  Note that the the ordering of @\
!           these ungridded dimensions is the same as their order in the {\tt farray}. @\
!           Note also that the bounds for undistributed dimensions included in the {\tt grid} are set @\
!           in the {\tt grid}. @\
!     \item [{[maxHaloLWidth]}]
!           Lower bound of halo region.  The size of this array is the number @\
!           of distributed dimensions in the {\tt grid}.  However, ordering of the elements @\
!           needs to be the same as they appear in the {\tt farray}.  Values default @\
!           to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!           the size of the {\tt farray}.  That is, for each distributed dimension the @\
!           {\tt farray} size should be {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!           + {\tt computationalCount}. Although the halo operation is not @\
!           implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!           in preparation for the implementation of the halo method. @\
!           HALO OPERATION NOT IMPLEMENTED @\
!     \item [{[maxHaloUWidth]}]
!           Upper bound of halo region.  The size of this array is the number @\
!           of distributed dimensions in the {\tt grid}.  However, ordering of the elements @\
!           needs to be the same as they appear in the {\tt farray}.  Values default @\
!           to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!           the size of the {\tt farray}.  That is, for each distributed dimension the @\
!           {\tt farray} size should {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!           + {\tt computationalCount}.  Although the halo operation is not @\
!           implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!           in preparation for the implementation of the halo method.  @\
!           HALO OPERATION NOT IMPLEMENTED @\
!     \item [{[name]}] 
!           {\tt Field} name. 
!     \item [{[iospec]}] 
!           I/O specification. ! NOT IMPLEMENTED
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

      type(ESMF_FieldType), pointer :: ftype      ! Pointer to new field
      integer :: localrc                          !  Local error code
      logical :: rcpresent                        ! Return code present

      ! Initialize pointers
      localrc = ESMF_RC_NOT_IMPL
      rcpresent = .FALSE.
      nullify(ftype)
      nullify(ESMF_FieldCreateNew%ftypep)

      ! Initialize return code   
      if(present(rc)) then
        rcpresent=.TRUE.
        rc = ESMF_RC_NOT_IMPL
      endif

      allocate(ftype, stat=localrc)
      ! If error write message and return.
      ! Formal error handling will be added asap.
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
      call ESMF_FieldInitialize(ftype, rc=localrc) 
      if (ESMF_LogMsgFoundAllocError(localrc, "Default initialize Field", &
                                       ESMF_CONTEXT, rc)) return

      ! Call construction method to allocate and initialize field internals.
      call ESMF_FieldConstructIA(ftype, grid, arrayspec, allocflag, &
                                  staggerloc, gridToFieldMap, ungriddedLBound, &
                                  ungriddedUBound, maxHaloLWidth, &
                                  maxHaloUWidth, name, iospec, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
   
      ! Set return values.
      ESMF_FieldCreateNew%ftypep => ftype

      ESMF_INIT_SET_CREATED(ESMF_FieldCreateNew)
      if(rcpresent) rc = ESMF_SUCCESS

      end function ESMF_FieldCreateNew

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateFromArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from Grid and Array

! !INTERFACE:
      ! Private name; call using ESMF_FieldCreate()
      function ESMF_FieldCreateFromArray(grid, array, copyflag, staggerloc, &
                                         gridToFieldMap, ungriddedLBound, &
                                         ungriddedUBound, maxHaloLWidth, &
                                         maxHaloUWidth, name, &
                                         iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Field) :: ESMF_FieldCreateFromArray    
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(in) :: grid                
      type(ESMF_Array), intent(in) :: array              
      type(ESMF_CopyFlag), intent(in), optional :: copyflag       
      type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
      integer, intent(in), optional :: gridToFieldMap(:)    
      integer, intent(in), optional :: ungriddedLBound(:)
      integer, intent(in), optional :: ungriddedUBound(:)
      integer, intent(in), optional :: maxHaloLWidth(:)
      integer, intent(in), optional :: maxHaloUWidth(:)
      character (len = *), intent(in), optional :: name   
      type(ESMF_IOSpec), intent(in), optional :: iospec   
      integer, intent(out), optional :: rc                
!
! !DESCRIPTION:
!     Create an {\tt ESMF\_Field}.  This version of creation
!     assumes the data exists already and is being
!     passed in through an {\tt ESMF\_Array}.  
! 
!     The arguments are:
!     \begin{description}
!     \item [grid] 
!           Pointer to an {\tt ESMF\_Grid} object. 
!     \item [array]
!           Includes data specification and allocated memory. 
!           It must already include space for the halo regions.
!     \item [{[copyflag]}]
!           Indicates whether to copy the {\tt farray} or reference it directly. @\
!           For valid values see \ref{opt:copyflag}.  The default is @\
!           {\tt ESMF\_DATA\_REF}. @\
!     \item [{[staggerloc]}] 
!           Stagger location of data in grid cells.  For valid  @\
!           predefined values see Section \ref{sec:opt:staggerloc}. @\
!           To create a custom stagger location see Section @\
!           \ref{sec:usage:staggerloc:adv}. The default @\
!           value is ESMF\_STAGGERLOC\_CENTER. @\
!     \item [{[gridToFieldMap]}]
!           List with number of elements equal to the @\
!           {\tt grid}'s dimCount.  The list elements map each dimension @\
!           of the {\tt grid} to a dimension in the {\tt farray} by @\
!           specifying the appropriate {\tt farray} dimension index. The default is to @\
!           map all of the {\tt grid}'s dimensions against the lowest dimensions of @\
!           the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!           The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!           to one and smaller than or equal to the {\tt farray} rank. @\
!           It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!           multiple times. The total ungridded dimensions in the {\tt field} @\
!           are the total {\tt farray} dimensions less @\
!           the total (distributed + undistributed) dimensions in @\
!           the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!           stored in the {\t farray}.  Permutations of the order of @\
!           dimensions are handled via individual communication methods.  For example, @\
!           an undistributed dimension can be remapped to a distributed dimension @\
!           as part of the ESMF\_ ArrayRedist() operation. @\
!     \item [{[ungriddedLBound]}]
!           Lower bounds of the ungridded dimensions of the {\tt field}. @\
!           The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!           dimensions in the {\tt field}.  All ungridded dimensions of the @\
!           {\tt field} are also undistributed. If neither ungriddedLBounds or @\
!           ungriddedUBounds are specified, the ungriddedLBound defaults to 1, @\
!           and the ungriddedUBound defaults to the size of the dimension. @\
!           If either ungriddedLBounds OR ungriddedUBounds are specified, the @\
!           other will be calculated.  If BOTH are specified the values are checked @\
!           for consistency.  Note that the the ordering of @\
!           these ungridded dimensions is the same as their order in the {\tt farray}. @\
!           Note also that the bounds for undistributed dimensions included in the {\tt grid} are set @\
!           in the {\tt grid}. @\
!     \item [{[ungriddedUBound]}]
!           Upper bounds of the ungridded dimensions of the {\tt field}. @\
!           The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!           dimensions in the {\tt field}.  All ungridded dimensions of the @\
!           {\tt field} are also undistributed. If neither ungriddedLBounds or @\
!           ungriddedUBounds are specified, the ungriddedLBound defaults to 1, @\
!           and the ungriddedUBound defaults to the size of the dimension. @\
!           If either ungriddedLBounds OR ungriddedUBounds are specified, the @\
!           other will be calculated.  If BOTH are specified the values are checked @\
!           for consistency.  Note that the the ordering of @\
!           these ungridded dimensions is the same as their order in the {\tt farray}. @\
!           Note also that the bounds for undistributed dimensions included in the {\tt grid} are set @\
!           in the {\tt grid}. @\
!     \item [{[maxHaloLWidth]}]
!           Lower bound of halo region.  The size of this array is the number @\
!           of distributed dimensions in the {\tt grid}.  However, ordering of the elements @\
!           needs to be the same as they appear in the {\tt farray}.  Values default @\
!           to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!           the size of the {\tt farray}.  That is, for each distributed dimension the @\
!           {\tt farray} size should be {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!           + {\tt computationalCount}. Although the halo operation is not @\
!           implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!           in preparation for the implementation of the halo method. @\
!           HALO OPERATION NOT IMPLEMENTED @\
!     \item [{[maxHaloUWidth]}]
!           Upper bound of halo region.  The size of this array is the number @\
!           of distributed dimensions in the {\tt grid}.  However, ordering of the elements @\
!           needs to be the same as they appear in the {\tt farray}.  Values default @\
!           to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!           the size of the {\tt farray}.  That is, for each distributed dimension the @\
!           {\tt farray} size should {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!           + {\tt computationalCount}.  Although the halo operation is not @\
!           implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!           in preparation for the implementation of the halo method.  @\
!           HALO OPERATION NOT IMPLEMENTED @\
!     \item [{[name]}] 
!           {\tt Field} name. 
!     \item [{[iospec]}] 
!           I/O specification. NOT IMPLEMENTED
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

      type(ESMF_FieldType), pointer :: ftype  ! Pointer to new field
      integer :: localrc                       !  Local error code
      logical :: rcpresent                    ! Return code present
      
      ! Initialize pointers
      localrc = ESMF_RC_NOT_IMPL
      rcpresent = .FALSE.
      nullify(ftype)
      nullify(ESMF_FieldCreateFromArray%ftypep)

      ! Initialize return code   
      if(present(rc)) then
        rcpresent = .TRUE. 
        rc = ESMF_RC_NOT_IMPL
      endif     

      allocate(ftype, stat=localrc)
      if (ESMF_LogMsgFoundAllocError(localrc, "Allocating Field information", &
                                       ESMF_CONTEXT, rc)) return
      call ESMF_FieldInitialize(ftype, rc=localrc) 
      if (ESMF_LogMsgFoundAllocError(localrc, "Default initialize Field", &
                                       ESMF_CONTEXT, rc)) return

      ! Call construction method to allocate and initialize field internals.
      call ESMF_FieldConstructIA(ftype, grid, array, copyflag, staggerloc, &
                                       gridToFieldMap, ungriddedLBound, &
                                       ungriddedUBound, maxHaloLWidth, &
                                       maxHaloUWidth, name, &
                                       iospec, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
   

      ! Set return values.
      ESMF_FieldCreateFromArray%ftypep => ftype
      ESMF_INIT_SET_CREATED(ESMF_FieldCreateFromArray)
      if(rcpresent) rc = ESMF_SUCCESS

      end function ESMF_FieldCreateFromArray

!------------------------------------------------------------------------------

      ! < declarations of subroutines for each T/K/R >

TypeKindRankDeclarationMacro(FieldSetCommit)
TypeKindRankDeclarationMacro(FieldCreateFromDataPtr)

!------------------------------------------------------------------------------


      end module ESMF_FieldCreateMod

