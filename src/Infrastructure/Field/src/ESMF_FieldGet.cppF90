! $Id: ESMF_FieldGet.cppF90,v 1.2.2.23 2008/04/02 03:55:46 theurich Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2007, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FieldGet.F90"
!==============================================================================
!
!     ESMF FieldGet module
module ESMF_FieldGetMod
!
!==============================================================================
!
! This file contains the FieldGet() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_TypeKindRankMacros.hcppF90"

!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod
  use ESMF_BaseMod
  use ESMF_LogErrMod
  use ESMF_IOSpecMod
  use ESMF_LocalArrayMod
  use ESMF_ArrayMod
  use ESMF_ArrayGetMod
  use ESMF_GridMod
  use ESMF_StaggerLocMod
  use ESMF_InitMacrosMod
  
  use ESMF_FieldMod
      
  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

  public ESMF_FieldGet
 
!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_FieldGet.cppF90,v 1.2.2.23 2008/04/02 03:55:46 theurich Exp $'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================


!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_FieldGet -- Overloaded FieldGet interface

! !INTERFACE:
  interface ESMF_FieldGet

! !PRIVATE MEMBER FUNCTIONS:
!
    module procedure ESMF_FieldGetDefault
    module procedure ESMF_FieldGetAllocBounds
    !module procedure ESMF_FieldGetLocalArray !TODO: FIELDINTEGRATION
    TypeKindRankInterfaceMacro(FieldGetDataPtr)

! !DESCRIPTION: 
! This interface provides a single entry point for the various 
!  types of {\tt ESMF\_FieldGet} subroutines.   
  end interface
!EOPI 
!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldGetDefault"
!BOP
! !IROUTINE: ESMF_FieldGet - Return info associated with a Field

! !INTERFACE:
  ! Private name; call using ESMF_FieldGet()
  subroutine ESMF_FieldGetDefault(field, grid, array, typekind, dimCount, &
    staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    maxHaloLWidth, maxHaloUWidth, name, iospec, rc) 
!
! !ARGUMENTS:
    type(ESMF_Field), intent(inout) :: field    
    type(ESMF_Grid), intent(out), optional :: grid     
    type(ESMF_Array), intent(out), optional :: array     
    type(ESMF_TypeKind), intent(out), optional :: typekind
    integer, intent(out), optional :: dimCount
    type(ESMF_StaggerLoc), intent(out), optional :: staggerloc 
    integer, intent(out), optional :: gridToFieldMap(:)    
    integer, intent(out), optional :: ungriddedLBound(:)
    integer, intent(out), optional :: ungriddedUBound(:)
    integer, intent(out), optional :: maxHaloLWidth(:)
    integer, intent(out), optional :: maxHaloUWidth(:)
    character(len=*), intent(out), optional :: name
    type(ESMF_IOSpec), intent(out), optional :: iospec ! NOT IMPLEMENTED
    integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
! Query an {\tt ESMF\_Field} for various things.  All arguments after
! the {\tt field} are optional.  To select individual items use the
! named\_argument=value syntax.
!
! The arguments are:
! \begin{description}
! \item [field]
!       {\tt ESMF\_Field} object to query.
! \item [{[grid]}]
!       {\tt ESMF\_Grid}.
! \item [{[array]}]
!       {\tt ESMF\_Array}.
! \item [{[typekind]}]
!       TypeKind specifier for Field.
! \item [{[dimCount]}]
!       Number of dimensions in {\tt field} data.
! \item [{[staggerloc]}]
!       Stagger location of data in grid cells.  For valid
!       predefined values and interpretation of results see
!       Section \ref{sec:opt:staggerloc}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the 
!       {\tt grid}'s dimCount.  The list elements map each dimension 
!       of the {\tt grid} to a dimension in the {\tt farray} by 
!       specifying the appropriate {\tt farray} dimension index. The default is to 
!       map all of the {\tt grid}'s dimensions against the lowest dimensions of 
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal 
!       to one and smaller than or equal to the {\tt farray} rank. 
!       It is erroneous to specify the same {\tt gridToFieldMap} entry 
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt farray} dimensions less
!       the total (distributed + undistributed) dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t farray}.  Permutations of the order of
!       dimensions are handled via individual communication methods.  For example,
!       an undistributed dimension can be remapped to a distributed dimension
!       as part of the ESMF\_ ArrayRedist() operation.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of
!       ungridded dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. If neither ungriddedLBounds or
!       ungriddedUBounds are specified, the ungriddedLBound defaults to 1,
!       and the ungriddedUBound defaults to the size of the dimension.
!       If either ungriddedLBounds OR ungriddedUBounds are specified, the
!       other will be calculated.  If BOTH are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt farray}.
!       Note also that the bounds for undistributed dimensions included in the
!       {\tt grid} are set in the {\tt grid}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of
!       ungridded dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. If neither ungriddedLBounds or
!       ungriddedUBounds are specified, the ungriddedLBound defaults to 1,
!       and the ungriddedUBound defaults to the size of the dimension.
!       If either ungriddedLBounds OR ungriddedUBounds are specified, the
!       other will be calculated.  If BOTH are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt farray}.
!       Note also that the bounds for undistributed dimensions included in the
!       {\tt grid} are set in the {\tt grid}.
! \item [{[maxHaloLWidth]}]
!       Lower bounds of halo region.  The size of this array is the number
!       of distributed dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt farray}.  Values default
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in
!       the size of the {\tt farray}.  That is, for each distributed dimension the
!       {\tt farray} size should be {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
!       + {\tt computationalCount}. Although the halo operation is not
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method.
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[maxHaloUWidth]}]
!       Upper bounds of halo region.  The size of this array is the number
!       of distributed dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt farray}.  Values default
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in
!       the size of the {\tt farray}.  That is, for each distributed dimension the
!       {\tt farray} size should {\tt maxHaloLWidth} + {\tt maxHaloUWidth}
!       + {\tt computationalCount}.  Although the halo operation is not
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method.
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[name]}]
!       Name of queried item.
! \item [{[iospec]}]
!       {\tt ESMF\_IOSpec} object which contains settings for options. NOT IMPLEMENTED
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    type(ESMF_FieldType), pointer :: ftype
    integer :: localrc

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ! check variables
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

    ! Validate object first
    call ESMF_FieldValidate(field, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                             ESMF_ERR_PASSTHRU, &
                             ESMF_CONTEXT, rc)) return
 
    ftype => field%ftypep

    if (present(grid)) then
        if (ftype%gridstatus .ne. ESMF_STATUS_READY) then
            if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                            "No Grid or invalid Grid attached to Field", &
                             ESMF_CONTEXT, rc)) return
        endif
        grid = ftype%grid
    endif

    if (present(array)) then
        if (ftype%datastatus .ne. ESMF_STATUS_READY) then
            if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                            "No data attached to Field", &
                             ESMF_CONTEXT, rc)) return
        endif
        array = ftype%array
    endif

    if (present(gridToFieldMap)) then
        gridToFieldMap = ftype%gridToFieldMap
    endif

    if (present(ungriddedLBound)) then
        ungriddedLBound = ftype%ungriddedLBound
    endif

    if (present(ungriddedUBound)) then
        ungriddedUBound = ftype%ungriddedUBound
    endif

    if (present(maxHaloLWidth)) then
        maxHaloLWidth = ftype%maxHaloLWidth
    endif

    if (present(ungriddedUBound)) then
        maxHaloUWidth = ftype%maxHaloUWidth
    endif

    if (present(staggerloc)) then
        staggerloc = ftype%staggerloc
    endif

    if (present(typekind)) then
        if (ftype%datastatus .ne. ESMF_STATUS_READY) then
            if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
             "Cannot return typekind because no data attached to Field", &
                             ESMF_CONTEXT, rc)) return
        endif
        call ESMF_ArrayGet(ftype%array, &
                           typekind=typekind, rc=rc)
        if (ESMF_LogMsgFoundError(rc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
    endif

    if (present(dimCount)) then
        if (ftype%datastatus .ne. ESMF_STATUS_READY) then
            if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
             "Cannot return dimCount because no data attached to Field", &
                             ESMF_CONTEXT, rc)) return
        endif
        call ESMF_ArrayGet(ftype%array, &
                           rank=dimCount, rc=rc)
        if (ESMF_LogMsgFoundError(rc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
    endif

    if (present(iospec)) iospec = ftype%iospec

    if (present(name)) then
        call c_ESMC_GetName(ftype%base, name, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                              ESMF_ERR_PASSTHRU, &
                              ESMF_CONTEXT, rc)) return
    endif

    if (present(rc)) rc = ESMF_SUCCESS

  end subroutine ESMF_FieldGetDefault
!------------------------------------------------------------------------------


! TODO:FIELDINTEGRATION Restore FieldGetLocalArray
#if 0
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldGetLocalArray"
!BOPI
! !IROUTINE: ESMF_FieldGet - Get LocalArray associated with the Field

! !INTERFACE:
  ! Private name; call using ESMF_FieldGet()
  subroutine ESMF_FieldGetLocalArray(field, localarray, rc)
!
! !ARGUMENTS:
    type(ESMF_Field), intent(inout) :: field
    type(ESMF_LocalArray), intent(out) :: localarray
    integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Get data in {\tt ESMF\_LocalArray} form.
!
! The arguments are:
! \begin{description}
! \item [field]
!       An {\tt ESMF\_Field} object.
! \item [{[localarray]}]
!       Field {\tt ESMF\_LocalArray}.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOPI
!------------------------------------------------------------------------------
    integer :: localrc 
    !character(len=ESMF_MAXSTR) :: str
    type(ESMF_Array) :: array

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ! check variables
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

    ! Validate first
    call ESMF_FieldValidate(field, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                              ESMF_ERR_PASSTHRU, &
                              ESMF_CONTEXT, rc)) return

    call ESMF_FieldGetArray(field, array, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                              ESMF_ERR_PASSTHRU, &
                              ESMF_CONTEXT, rc)) return


    call ESMF_ArrayGet(array, localarray, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                              ESMF_ERR_PASSTHRU, &
                              ESMF_CONTEXT, rc)) return
    
    ! Set return values.
    if (present(rc)) rc = ESMF_SUCCESS

  end subroutine ESMF_FieldGetLocalArray
!------------------------------------------------------------------------------
#endif


#define FieldGetDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldGet - Get Fortran data pointer from a Field @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldGet() @\
! subroutine ESMF_FieldGetDataPtr<rank><type><kind>(field, localDe, farray, & @\
!   exclusiveLBound, exclusiveUBound, exclusiveCount, & @\
!   computationalLBound, computationalUBound, computationalCount, & @\
!   totalLBound, totalUBound, totalCount, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Field), intent(in)            :: field @\
!   integer,          intent(in)            :: localDe @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer  :: farray @\
!   integer,          intent(out), optional :: exclusiveLBound(:) @\
!   integer,          intent(out), optional :: exclusiveUBound(:) @\
!   integer,          intent(out), optional :: exclusiveCount(:) @\
!   integer,          intent(out), optional :: computationalLBound(:) @\
!   integer,          intent(out), optional :: computationalUBound(:) @\
!   integer,          intent(out), optional :: computationalCount(:) @\
!   integer,          intent(out), optional :: totalLBound(:) @\
!   integer,          intent(out), optional :: totalUBound(:) @\
!   integer,          intent(out), optional :: totalCount(:) @\
!   integer,          intent(out), optional :: rc @\
! @\
! !DESCRIPTION: @\
! Get a Fortran pointer to DE-local memory allocation within {\tt field}. @\
! For convenience DE-local bounds can be queried at the same time. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [field]  @\
!   {\tt ESMF\_Field} object. @\
! \item[localDe] @\
!   The local DE from which to get the information. @\
! \item [farray] @\
!   Fortran array pointer which will be pointed at DE-local memory allocation. @\
! \item[{[exclusiveLBound]}] @\
!   Upon return this holds the lower bounds of the exclusive region. @\
!   {\tt exclusiveLBound} must be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[exclusiveUBound]}] @\
!   Upon return this holds the upper bounds of the exclusive region. @\
!   {\tt exclusiveUBound} must be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[exclusiveCount]}] @\
!   Upon return this holds the number of items in the exclusive region per dimension @\
!   (i.e. {\tt exclusiveUBound-exclusiveLBound+1}). {\tt exclusiveCount} must @\
!   be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[computationalLBound]}] @\
!   Upon return this holds the lower bounds of the computational region. @\
!   {\tt computationalLBound} must be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[computationalUBound]}] @\
!   Upon return this holds the lower bounds of the computational region. @\
!   {\tt computationalLBound} must be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[computationalCount]}] @\
!   Upon return this holds the number of items in the computational region per dimension @\
!   (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount} must @\
!   be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[totalLBound]}] @\
!   Upon return this holds the lower bounds of the total region. @\
!   {\tt totalLBound} must be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[totalUBound]}] @\
!   Upon return this holds the lower bounds of the total region. @\
!   {\tt totalUBound} must be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item[{[totalCount]}] @\
!   Upon return this holds the number of items in the total region per dimension @\
!   (i.e. {\tt totalUBound-totalLBound+1}). {\tt computationalCount} must @\
!   be allocated to be of size equal to {\tt field}|s {\tt dimCount}. @\
!   See section \ref{sec:field:usage:bounds} for a description @\
!   of the regions and their associated bounds and counts.  @\
! \item [{[rc]}]  @\
!   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldGetDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldGetDataPtr" @\
  subroutine ESMF_FieldGetDataPtr##mrank##D##mtypekind(field, localDe, farray, & @\
    exclusiveLBound, exclusiveUBound, exclusiveCount, & @\
    computationalLBound, computationalUBound, computationalCount, & @\
    totalLBound, totalUBound, totalCount, rc) @\
@\
    ! input arguments @\
    type(ESMF_Field), intent(in)            :: field @\
    integer,          intent(in)            :: localDe @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farray @\
    integer,          intent(out), optional :: exclusiveLBound(:) @\
    integer,          intent(out), optional :: exclusiveUBound(:) @\
    integer,          intent(out), optional :: exclusiveCount(:) @\
    integer,          intent(out), optional :: computationalLBound(:) @\
    integer,          intent(out), optional :: computationalUBound(:) @\
    integer,          intent(out), optional :: computationalCount(:) @\
    integer,          intent(out), optional :: totalLBound(:) @\
    integer,          intent(out), optional :: totalUBound(:) @\
    integer,          intent(out), optional :: totalCount(:) @\
    integer,          intent(out), optional :: rc @\
@\
    ! local variables @\
    integer          :: localrc @\
@\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ! check variables @\
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) @\
@\
    call ESMF_ArrayGet(field%ftypep%array, localDe=localDe, & @\
      farrayPtr=farray, rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    call ESMF_FieldGetDataBounds(field, localDe, & @\
        exclusiveLBound, exclusiveUBound, exclusiveCount, & @\
        computationalLBound, computationalUBound, computationalCount, & @\
        totalLBound, totalUBound, totalCount, & @\
        rc = localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
@\
  end subroutine ESMF_FieldGetDataPtr##mrank##D##mtypekind  @\
!---------------------------------------------------------------------------- @\

TypeKindRankDeclarationMacro(FieldGetDataPtr)


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldGetDataBounds"
!BOPI
! !IROUTINE: ESMF_FieldGetDataBounds -  Get Field data bounds

! !INTERFACE:
  subroutine ESMF_FieldGetDataBounds(field, localDe, exclusiveLBound, &
    exclusiveUBound, exclusiveCount, computationalLBound, computationalUBound, &
    computationalCount, totalLBound, totalUBound, totalCount, rc)

! !ARGUMENTS:
    type(ESMF_Field),       intent(in) :: field
    integer,                intent(in) :: localDe
    integer,                intent(out), optional :: exclusiveLBound(:)
    integer,                intent(out), optional :: exclusiveUBound(:)
    integer,                intent(out), optional :: exclusiveCount(:)
    integer,                intent(out), optional :: computationalLBound(:)
    integer,                intent(out), optional :: computationalUBound(:)
    integer,                intent(out), optional :: computationalCount(:)
    integer,                intent(out), optional :: totalLBound(:)
    integer,                intent(out), optional :: totalUBound(:)
    integer,                intent(out), optional :: totalCount(:)
    integer,                intent(out), optional :: rc

! !DESCRIPTION:
! This method returns the bounds information of a field that consists of a
! internal grid and a internal array. The exclusive and computational bounds
! are shared between the grid and the array but the total bounds are the array
! bounds plus the halo width. The count is the number of elements between each
! bound pair.
!
! The arguments are:
! \begin{description}
! \item[field]
!    Field to get the information from.
! \item[localDe]
!     The local DE from which to get the information.  
! \item[{[exclusiveLBound]}]
!     Upon return this holds the lower bounds of the exclusive region.
!     {\tt exclusiveLBound} must be allocated to be of size equal to the field rank.
!     Please see Section~\ref{sec:grid:usage:bounds} for a description
!     of the regions and their associated bounds and counts. 
! \item[{[exclusiveUBound]}]
!     Upon return this holds the upper bounds of the exclusive region.
!     {\tt exclusiveUBound} must be allocated to be of size equal to the field rank.
!     Please see Section~\ref{sec:grid:usage:bounds} for a description
!     of the regions and their associated bounds and counts. 
! \item[{[exclusiveCount]}]
!     Upon return this holds the number of items in the exclusive region per dimension
!     (i.e. {\tt exclusiveUBound-exclusiveLBound+1}). {\tt exclusiveCount} must
!     be allocated to be of size equal to the field rank.
!     Please see Section~\ref{sec:grid:usage:bounds} for a description
!     of the regions and their associated bounds and counts. 
! \item[{[computationalLBound]}]
!     Upon return this holds the lower bounds of the stagger region.
!     {\tt computationalLBound} must be allocated to be of size equal to the field rank.
!     Please see Section~\ref{sec:grid:usage:bounds} for a description
!     of the regions and their associated bounds and counts. 
! \item[{[computationalUBound]}]
!     Upon return this holds the upper bounds of the stagger region.
!     {\tt computationalUBound} must be allocated to be of size equal to the field rank.
!     Please see Section~\ref{sec:grid:usage:bounds} for a description
!     of the regions and their associated bounds and counts. 
! \item[{[computationalCount]}]
!     Upon return this holds the number of items in the computational region per dimension
!     (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount}
!      must be allocated to be of size equal to the field rank.
!     Please see Section~\ref{sec:grid:usage:bounds} for a description
!     of the regions and their associated bounds and counts. 
! \item[{[totalLBound]}]
!     Upon return this holds the lower bounds of the total region.
!     {\tt totalLBound} must be allocated to be of size equal to the field rank.
! \item[{[totalUBound]}]
!     Upon return this holds the upper bounds of the total region.
!     {\tt totalUBound} must be allocated to be of size equal to the field rank.
! \item[{[totalCount]}]
!     Upon return this holds the number of items in the total region per dimension
!     (i.e. {\tt totalUBound-totalLBound+1}). {\tt totalCount} must
!      be allocated to be of size equal to the field rank.
! \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOPI
!------------------------------------------------------------------------------
    integer :: gridCompLBnd(ESMF_MAXDIM), gridCompUBnd(ESMF_MAXDIM)
    integer :: gridExclLBnd(ESMF_MAXDIM), gridExclUBnd(ESMF_MAXDIM)
    integer :: gridTotaLBnd(ESMF_MAXDIM), gridTotaUBnd(ESMF_MAXDIM)
    integer :: gridrank, fieldrank, localrc
    integer :: i, j
    logical :: filled(ESMF_MAXDIM)

    integer :: localDeCount, dimCount
    integer, allocatable :: arrayBnd(:, :)
    integer, allocatable :: undistBnd(:)
    integer, allocatable :: distgridToArrayMap(:)
    integer, allocatable :: distgridToPackedArrayMap(:)

    if (present(rc)) rc = ESMF_RC_NOT_IMPL 
    localrc = ESMF_RC_NOT_IMPL

    ! check variables
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

    call ESMF_GridGet(field%ftypep%grid, dimCount=gridrank, rc=localrc)
    if (localrc .ne. ESMF_SUCCESS) then
       call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, &
          "Cannot retrieve gridrank from ftypep%grid", &
           ESMF_CONTEXT, rc)
       return
    endif 
    call ESMF_ArrayGet(field%ftypep%array, rank=fieldrank, rc=localrc)
    if (localrc .ne. ESMF_SUCCESS) then
       call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, &
          "Cannot retrieve fieldrank from ftypep%array", &
           ESMF_CONTEXT, rc)
       return
    endif 

    if(present(exclusiveLBound)) then
        if(size(exclusiveLBound) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of exclusiveLBound must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(exclusiveUBound)) then
        if(size(exclusiveUBound) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of exclusiveUBound must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(exclusiveCount)) then
        if(size(exclusiveCount) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of exclusiveCount must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(computationalLBound)) then
        if(size(computationalLBound) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of computationalLBound must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(computationalUBound)) then
        if(size(computationalUBound) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of computationalUBound must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(computationalCount)) then
        if(size(computationalCount) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of computationalCount must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(totalLBound)) then
        if(size(totalLBound) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of totalLBound must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(totalUBound)) then
        if(size(totalUBound) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of totalUBound must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(totalCount)) then
        if(size(totalCount) .ne. fieldrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "the size of totalCount must equal to the field rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif

    if (present(totalLBound) .or. present(totalUBound)) then
    
        ! Get Size of Array info
        call ESMF_ArrayGet(field%ftypep%array, localDeCount=localDeCount, &
            dimCount=dimCount, rc=localrc)
    
        ! Allocate storage for Array info
        allocate(arrayBnd(dimCount, 0:localDeCount-1))
        allocate(undistBnd(fieldRank-dimCount))
        allocate(distgridToPackedArrayMap(dimCount))
        allocate(distgridToArrayMap(dimCount))
              
       ! get distributed dimension map
       call ESMF_ArrayGet(field%ftypep%array, & 
         distgridToPackedArrayMap=distgridToPackedArrayMap, &
         distgridToArrayMap=distgridToArrayMap, rc=localrc)
    
        ! fill totalLBounds
        if (present(totalLBound)) then
            call ESMF_ArrayGet(field%ftypep%array, totalLBound=arrayBnd, & 
                undistLBound=undistBnd, rc=localrc)
    
            ! set distributed dimensions
            filled=.false.
            do i=1, dimCount
               totalLBound(distgridToArrayMap(i))=&
                arrayBnd(distgridToPackedArrayMap(i),localDe)
               filled(distgridToArrayMap(i))=.true.
            enddo
    
            ! set undistributed dimensions
            j=1
            do i=1, fieldRank
               if (.not. filled(i)) then
                   totalLBound(i)=undistBnd(j)
                   j=j+1;
               endif
            enddo
        endif
    
        ! fill totalUBounds
        if (present(totalUBound)) then
            call ESMF_ArrayGet(field%ftypep%array, totalUBound=arrayBnd, & 
                undistUBound=undistBnd, rc=localrc)
    
            ! set distributed dimensions
            filled=.false.
            do i=1, dimCount
               totalUBound(distgridToArrayMap(i))=&
                arrayBnd(distgridToPackedArrayMap(i),localDe)
               filled(distgridToArrayMap(i))=.true.
            enddo
    
            ! set undistributed dimensions
            j=1
            do i=1, fieldRank
               if (.not. filled(i)) then
                   totalUBound(i)=undistBnd(j)
                   j=j+1;
               endif
           enddo
        endif
        ! deallocate data
        deallocate(arrayBnd)
        deallocate(undistBnd)
        deallocate(distgridToPackedArrayMap)
        deallocate(distgridToArrayMap)
    endif

    ! get grid info 
    call ESMF_GridGet(field%ftypep%grid, localDe=localDe, & 
            staggerloc=field%ftypep%staggerloc, & 
            computationalLBound=gridCompLBnd, &
            computationalUBound=gridCompUBnd, &
            exclusiveLBound=gridExclLBnd, &
            exclusiveUBound=gridExclUBnd, &
            rc=localrc) 
 
    ! fill in Grid bounds 
    filled=.false. 
    do i=1, gridrank 
        if(present(computationalLBound)) &
           computationalLBound(field%ftypep%gridToFieldMap(i))=gridCompLBnd(i) 
        if(present(computationalUBound)) &
           computationalUBound(field%ftypep%gridToFieldMap(i))=gridCompUBnd(i) 
        if(present(exclusiveLBound)) &
           exclusiveLBound(field%ftypep%gridToFieldMap(i))=gridExclLBnd(i) 
        if(present(exclusiveUBound)) &
           exclusiveUBound(field%ftypep%gridToFieldMap(i))=gridExclUBnd(i) 
       filled(field%ftypep%gridToFieldMap(i))=.true. 
    enddo
 
    ! fill in ungridded bounds
    j=1
    do i=1,fieldrank
       if (.not. filled(i)) then
        if(present(computationalLBound)) &
              computationalLBound(i)=field%ftypep%ungriddedLBound(j) 
        if(present(computationalUBound)) &
              computationalUBound(i)=field%ftypep%ungriddedUBound(j) 
        if(present(exclusiveLBound)) &
             exclusiveLBound(i)=field%ftypep%ungriddedLBound(j) 
        if(present(exclusiveUBound)) &
              exclusiveUBound(i)=field%ftypep%ungriddedUBound(j) 
          j=j+1
       endif
    enddo

    do i = 1, fieldrank 
        if(present(computationalCount)) &
            computationalCount(i) = computationalUBound(i) - computationalLBound(i) + 1
        if(present(exclusiveCount)) &
            exclusiveCount(i) = exclusiveUBound(i) - exclusiveLBound(i) + 1
        if(present(totalCount)) &
            totalCount(i) = totalUBound(i) - totalLBound(i) + 1
    end do

    if (present(rc)) rc = ESMF_SUCCESS
  end subroutine ESMF_FieldGetDataBounds
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldGetAllocBounds"
!BOP
! !IROUTINE: ESMF_FieldGet -  Get precomputed Fortran data array bounds

! !INTERFACE:
  ! Private name; call using ESMF_FieldGet()
    subroutine ESMF_FieldGetAllocBounds(grid, localDe, staggerloc, gridToFieldMap, &
        ungriddedLBound, ungriddedUBound, &
        maxHaloLWidth, maxHaloUWidth, &
        allocLBound, allocUBound, allocCount, rc)
    
! !ARGUMENTS:
    type(ESMF_Grid), intent(inout) :: grid     
    integer, intent(in)            :: localDe
    type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
    integer, intent(in), optional :: gridToFieldMap(:)    
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    integer, intent(in), optional :: maxHaloLWidth(:)
    integer, intent(in), optional :: maxHaloUWidth(:)
    integer, intent(out), optional :: allocLBound(:)
    integer, intent(out), optional :: allocUBound(:)
    integer, intent(out), optional :: allocCount(:)
    integer, intent(out), optional :: rc     

!
! !DESCRIPTION:
! Compute the lower and upper bounds of Fortran data array that can later
! be used in FieldCreate interface to create a {\tt ESMF\_Field} from a
! {\tt ESMF\_Grid} and the Fortran data array. 
!
! The arguments are:
! \begin{description}
! \item [grid]
!       {\tt ESMF\_Grid}.
! \item [localDe]
!       The local DE number in its PET context to compute the bounds and counts
!       information based on the computational and exclusive bounds and counts 
!       information of the grid from that local DE in its PET context.
! \item [{[staggerloc]}]
!       Stagger location of data in grid cells.  For valid
!       predefined values and interpretation of results see
!       Section \ref{sec:opt:staggerloc}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the 
!       {\tt grid}'s dimCount.  The list elements map each dimension 
!       of the {\tt grid} to a dimension in the {\tt farray} by 
!       specifying the appropriate {\tt farray} dimension index. The default is to 
!       map all of the {\tt grid}'s dimensions against the lowest dimensions of 
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal 
!       to one and smaller than or equal to the {\tt farray} rank. 
!       It is erroneous to specify the same {\tt gridToFieldMap} entry 
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt farray} dimensions less
!       the total (distributed + undistributed) dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t farray}.  Permutations of the order of
!       dimensions are handled via individual communication methods.  For example,
!       an undistributed dimension can be remapped to a distributed dimension
!       as part of the ESMF\_ ArrayRedist() operation.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of
!       ungridded dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. If neither ungriddedLBounds or
!       ungriddedUBounds are specified, the ungriddedLBound defaults to 1,
!       and the ungriddedUBound defaults to the size of the dimension.
!       If BOTH are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt farray}.
!       Note also that the bounds for undistributed dimensions included in the
!       {\tt grid} are set in the {\tt grid}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of
!       ungridded dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. If neither ungriddedLBounds or
!       ungriddedUBounds are specified, the ungriddedLBound defaults to 1,
!       and the ungriddedUBound defaults to the size of the dimension.
!       If BOTH are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt farray}.
!       Note also that the bounds for undistributed dimensions included in the
!       {\tt grid} are set in the {\tt grid}.
! \item [{[maxHaloLWidth]}]
!       Lower bounds of halo region.  The size of this array is the number
!       of distributed dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt farray}.  Values default
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in
!       the size of the {\tt farray}.  That is, for each distributed dimension the
!       {\tt farray} size should be {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
!       + {\tt computationalCount}. Although the halo operation is not
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method.
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[maxHaloUWidth]}]
!       Upper bounds of halo region.  The size of this array is the number
!       of distributed dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt farray}.  Values default
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in
!       the size of the {\tt farray}.  That is, for each distributed dimension the
!       {\tt farray} size should {\tt maxHaloLWidth} + {\tt maxHaloUWidth}
!       + {\tt computationalCount}.  Although the halo operation is not
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method.
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[allocLBound]}]
!       The relative lower bounds of Fortran data array to be used
!       later in {tt ESMF\_FieldCreate} from {\tt ESMF\_Grid} and Fortran data array.
!       This is an output variable from this user interface.
! \item [{[allocUBound]}]
!       The relative upper bounds of Fortran data array to be used
!       later in {tt ESMF\_FieldCreate} from {\tt ESMF\_Grid} and Fortran data array.
!       This is an output variable from this user interface.
! \item [{[allocCount]}]
!       Number of elements need to be allocated for Fortran data array to be used
!       later in {tt ESMF\_FieldCreate} from {\tt ESMF\_Grid} and Fortran data array.
!       This is an output variable from this user interface.
!
! \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP

!  !Local Variables
    integer :: localrc

    type(ESMF_STAGGERLOC)                  :: lstaggerloc

    integer, dimension(ESMF_MAXDIM)        :: ec, cc, l_g2fm, l_mhlw, l_mhuw, dg2gm
    integer, dimension(ESMF_MAXDIM)        :: f2gm, gelb, geub, gclb, gcub
    logical, dimension(ESMF_MAXDIM)        :: flipflop
    integer                                :: forderIndex, i
    integer                                :: gridrank, arrayrank, uglb_size, ugub_size

    integer, dimension(:), allocatable     :: l_alb, l_aub, l_ac, l_uglb, l_ugub

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

    ! default staggerloc setup
    if(present(staggerloc)) then
        lstaggerloc = staggerloc
    else
        lstaggerloc = ESMF_STAGGERLOC_CENTER
    endif

    call ESMF_GridGet(grid, dimCount=gridrank, distgridToGridMap=dg2gm, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rc)) return
    call ESMF_GridGet(grid, localDe=localDe, staggerloc=lstaggerloc, &
       exclusiveLBound=gelb, exclusiveUBound=geub, exclusiveCount=ec,  &
       computationalLBound=gclb, computationalUBound=gcub, computationalCount=cc, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rc)) return

    ! check argument validity
    if(present(gridToFieldMap) ) then
        if(size(gridToFieldMap) .ne. gridrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "gridToFieldMap size must equal to grid dimension count", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif

    if(present(maxHaloLWidth) ) then
        if(size(maxHaloLWidth) .ne. gridrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "maxHaloLWidth size must equal to grid dimension count", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif

    if(present(maxHaloUWidth) ) then
        if(size(maxHaloUWidth) .ne. gridrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "maxHaloUWidth size must equal to grid dimension count", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif

    ! User must either provide both ungriddedLBound and ungriddedUBound
    ! with same size or don't specify either one of them. There is no
    ! suitable default value for unbounded variables.
    if(present(ungriddedLBound)) then
        uglb_size = size(ungriddedLBound)
    else 
        uglb_size = 0
    endif
    if(present(ungriddedUBound)) then
        ugub_size = size(ungriddedUBound)
    else
        ugub_size = 0
    endif

    if(uglb_size .ne. ugub_size) then
       call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
          "ungriddedLBound and ungriddedUBound must have same size", &
           ESMF_CONTEXT, rc)
       return
    endif 
    if(uglb_size .ne. 0) then
        allocate(l_uglb(uglb_size), l_ugub(ugub_size))
        l_uglb(1:uglb_size) = ungriddedLBound(1:uglb_size)
        l_ugub(1:ugub_size) = ungriddedUBound(1:ugub_size)
    endif

    ! the result Field/array rank
    arrayrank = gridrank + uglb_size

    ! check argument validity
    if(present(allocLBound)) then
        if(size(allocLBound) .ne. arrayrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "allocLBound size must equal to the desired array rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(allocUBound)) then
        if(size(allocUBound) .ne. arrayrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "allocUBound size must equal to the desired array rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif
    if(present(allocCount)) then
        if(size(allocCount) .ne. arrayrank) then
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
              "allocCount size must equal to the desired array rank", &
               ESMF_CONTEXT, rc)
           return
        endif 
    endif

    ! set up gridToFieldMap
    if(present(gridToFieldMap)) then
        l_g2fm(1:size(gridToFieldMap)) = gridToFieldMap
    else
        do i = 1, ESMF_MAXDIM
            l_g2fm(i) = i
        enddo
    endif
    ! gridToFieldMap elements must be in range 1...fieldRank and unique  
    ! algorithm to check element uniqueness:  
    !   run time: O(ESMF_MAXDIM)  
    !   memory:   O(2*ESMF_MAXDIM)  
    !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector  
    flipflop = .false.  
    do i = 1, gridrank
       if(l_g2fm(i) .lt. 1 .and. l_g2fm(i) .gt. arrayrank) then  
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &   
                 "- gridToFieldMap element must be within range 1...array rank", &  
                   ESMF_CONTEXT, rc)   
           return  
       endif  
       if(flipflop(l_g2fm(i))) then  
           call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &   
                 "- gridToFieldMap element must be unique", &  
                   ESMF_CONTEXT, rc)   
           return  
       endif  
       flipflop(l_g2fm(i)) = .true.  
    enddo  

    ! At this point input arguments are validated
    allocate(l_alb(arrayrank), l_aub(arrayrank), l_ac(arrayrank))
    l_mhlw = 0
    if(present(maxHaloLWidth)) then
        l_mhlw(1:gridrank) = maxHaloLWidth(1:gridrank)
    endif
    l_mhuw = 0
    if(present(maxHaloUWidth)) then
        l_mhuw(1:gridrank) = maxHaloUWidth(1:gridrank)
    endif

    ! First we compute the ungridded bounds:
    ! compute a reverse mapping then use rule 2 
    ! to compute ungridded Fortran array bounds
    f2gm = 0
    do i = 1, gridrank
        f2gm(l_g2fm(i)) = i
    enddo
    forderIndex = 1
    do i = 1, arrayrank
        ! if the i-th dimension is ungridded
        if(f2gm(i) .eq. 0) then
            l_alb(i) = l_uglb(forderIndex)
            l_aub(i) = l_ugub(forderIndex)
            l_ac(i)  = l_aub(i) - l_alb(i) + 1
            forderIndex = forderIndex + 1
        endif
    enddo

    ! Now compute the gridded bounds
    forderIndex = 1
    do i = 1, arrayrank
        ! if i-th dimension is distributed (including trivially distributed)
        if(f2gm(i) .gt. 0) then
            l_ac(i) = max(cc(f2gm(i))+l_mhlw(forderIndex)+l_mhuw(forderIndex), ec(f2gm(i)))
            l_alb(i) = gclb(f2gm(i)) - l_mhlw(forderIndex)
            l_aub(i) = l_alb(i) + l_ac(i) - 1
            forderIndex = forderIndex + 1
        endif
    enddo

    if(present(allocLBound)) allocLBound(1:arrayrank) = l_alb(1:arrayrank)
    if(present(allocUBound)) allocUBound(1:arrayrank) = l_aub(1:arrayrank)
    if(present(allocCount))  allocCount(1:arrayrank)  = l_ac(1:arrayrank)

    if (present(rc)) rc = ESMF_SUCCESS
    end subroutine ESMF_FieldGetAllocBounds

end module ESMF_FieldGetMod
