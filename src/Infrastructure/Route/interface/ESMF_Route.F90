! $Id: ESMF_Route.F90,v 1.55.2.1 2005/04/28 21:04:59 jwolfe Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2003, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the GPL.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_Route.F90"
!
!     ESMF Route Module
      module ESMF_RouteMod
!
!==============================================================================
!
! This file contains the F90 wrapper code for the C++ implementation of
!  the Route class.
!
!------------------------------------------------------------------------------
! INCLUDES
#include "ESMF.h"
!==============================================================================
!BOPI
! !MODULE: ESMF_RouteMod - Store and execute a predefined communication pattern
!
! !DESCRIPTION:
!
! The code in this file implements the F90 wrapper code for the C++
!  implementation of the {\tt ESMC\_Route} class.
!
!------------------------------------------------------------------------------
! !USES:
      use ESMF_BaseTypesMod
      use ESMF_BaseMod       
      use ESMF_LogErrMod
      use ESMF_DELayoutMod  
      use ESMF_LocalArrayMod
      use ESMF_XPacketMod  
      implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
      private

!------------------------------------------------------------------------------
!     !  ESMF_Route
!
!     ! Description of ESMF_Route. 

      type ESMF_Route
      sequence
      private
        type(ESMF_Pointer) :: this    ! opaque pointer to C++ class data
      end type

!------------------------------------------------------------------------------
! !PUBLIC TYPES:
      public ESMF_Route
!------------------------------------------------------------------------------
!
! !PUBLIC MEMBER FUNCTIONS:
!
      public ESMF_RouteCreate                 ! interface only, deep class
      public ESMF_RouteDestroy                ! interface only, deep class

      !public ESMF_RouteGet                    ! get and set values
      public ESMF_RouteSetSend
      public ESMF_RouteSetRecv
      public ESMF_RouteSetRecvItems

      public ESMF_RouteGetCached
      public ESMF_RouteGetRecvItems

      public ESMF_RoutePrecomputeHalo
      public ESMF_RoutePrecomputeRedist
      public ESMF_RoutePrecomputeRegrid
      public ESMF_RoutePrecomputeDomList
      public ESMF_RouteRun
      public ESMF_RouteRunF90PtrI411D
      public ESMF_RouteRunF90PtrI421D
      public ESMF_RouteRunF90PtrR811D
      public ESMF_RouteRunF90PtrR821D
      public ESMF_RouteRunF90PtrR832D
 
      public ESMF_RouteValidate
      public ESMF_RoutePrint
 
!
!
!EOPI

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
      character(*), parameter, private :: version = &
      '$Id: ESMF_Route.F90,v 1.55.2.1 2005/04/28 21:04:59 jwolfe Exp $'

!==============================================================================
!
      contains

!==============================================================================
!
! This section includes the Route Create and Destroy methods.
!
!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteCreate"
!BOPI
! !IROUTINE: ESMF_RouteCreate - Create a new Route

! !INTERFACE:
      function ESMF_RouteCreate(delayout, rc)
!
! !RETURN VALUE:
      type(ESMF_Route) :: ESMF_RouteCreate
!
! !ARGUMENTS:
      type(ESMF_DELayout), intent(in) :: delayout
      integer, intent(out), optional :: rc               
!
! !DESCRIPTION:
!     Allocates memory for a new {\tt ESMF\_Route} and constructs its
!     internals.
!
!     The arguments are:
!     \begin{description}
!     \item[delayout] 
!          An {\tt ESMF\_Layout} which encompasses all 
!          DEs involved in the route operation, both source and destination.  
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        type (ESMF_Route) :: route         ! new C++ Route
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   
        route%this = ESMF_NULL_POINTER

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++ create code
        call c_ESMC_RouteCreate(route, delayout, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        ! Set return values
        ESMF_RouteCreate = route

        if (rcpresent) rc = ESMF_SUCCESS

        end function ESMF_RouteCreate

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteDestroy"
!BOPI
! !IROUTINE: ESMF_RouteDestroy - Free all resources associated with a Route 

! !INTERFACE:
      subroutine ESMF_RouteDestroy(route, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(inout) :: route   
      integer, intent(out), optional :: rc        
!
! !DESCRIPTION:
!     Destroys an {\tt ESMF\_Route} previously allocated
!     via an {\tt ESMF_RouteCreate()} routine.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          The {\tt ESMF\_Route} to be destroyed.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++ destroy code
        call c_ESMC_RouteDestroy(route, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        ! nullify pointer
        route%this = ESMF_NULL_POINTER

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteDestroy


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteGet"
!BOPI
! !IROUTINE: ESMF_RouteGet - Get values from a Route

! !INTERFACE:
      subroutine ESMF_RouteGet(route, value1, value2, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(out), optional :: value1
      integer, intent(out), optional :: value2
      integer, intent(out), optional :: rc             

!
! !DESCRIPTION:
!     Queries information from an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be queried.
!     \item[{[value1]}]
!          Value to be retrieved.         
!     \item[{[value2]}]
!          Value to be retrieved.         
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        if (present(value1)) then
          ! code to be added here
        endif

        if (present(value2)) then
          ! code to be added here
        endif

        ! Call C++  code
!       call c_ESMC_RouteGet(route, value1, value2, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteGet


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteGetCached"
!BOPI
! !IROUTINE: ESMF_RouteGetCached - Search for a precomputed Route

! !INTERFACE:
      subroutine ESMF_RouteGetCached(rank, &
                 my_DE_dst, AI_dst_exc, AI_dst_tot, AI_dst_count, dstDElayout, &
                 my_DE_src, AI_src_exc, AI_src_tot, AI_src_count, srcDElayout, &
                 periodic, hascachedroute, route, rc)
!
! !ARGUMENTS:
      integer, intent(in) :: rank
      integer, intent(in) :: my_DE_dst
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_dst_exc
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_dst_tot
      integer, intent(in) :: AI_dst_count
      type(ESMF_DELayout), intent(in) :: dstDElayout
      integer, intent(in) :: my_DE_src
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_src_exc
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_src_tot
      integer, intent(in) :: AI_src_count
      type(ESMF_DELayout), intent(in) :: srcDElayout
      type(ESMF_Logical), dimension(:), intent(in) :: periodic
      logical, intent(out) :: hascachedroute
      type(ESMF_Route), intent(out) :: route
      integer, intent(out), optional :: rc            
!
! !DESCRIPTION:
!     Search for an appropriate precomputed {\tt ESMF\_Route}, trying to 
!     match the information given in the arguments with cached 
!     {\tt ESMF\_Route}s.  If an exact match is found, return
!     with {\tt hascachedroute} true, and return the {\tt ESMF\_Route}
!     which matched in the {\tt route} argument.
!
!     The arguments are:
!     \begin{description}
!     \item[rank]
!          Data rank.
!     \item[my_DE_dst]
!          The ID of the destination DE.
!     \item[AI_dst_exc]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          computational region of the data to be moved for each DE.
!          (Note: is this correct?  If so, then the name is misleading.)
!     \item[AI_dst_tot]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data to be move for each DE.
!     \item[AI_dst_count]
!          Integer number of DEs in the destination.
!     \item[dstDElayout]
!          {\tt ESMF\_DELayout} for the destination.
!     \item[my_DE_src]
!          The ID of the destination DE.
!     \item[AI_src_exc]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          exclusive region of the data to be moved for each DE.
!          (Note: is this actually the computational region?)
!     \item[AI_src_tot]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data to be move for each DE.
!     \item[AI_src_count]
!          Integer number of DEs in the source.
!     \item[srcDElayout]
!          {\tt ESMF\_DELayout} for the source.
!     \item[periodic]
!          An array of {\tt ESMF\_Logical} flags indicating whether the 
!          boundaries in each dimension are to be treated as periodic or not.
!          This affects the halo and regrid operations in particular.
!     \item[hascachedroute]
!          Logical return code for whether an {\tt ESMF\_Route} was found.
!     \item[route]
!          If found, the returned {\tt ESMF\_Route}.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        integer :: i,j                     ! counters
        logical :: rcpresent               ! did user specify rc?
        type(ESMF_Logical) :: lcache
        type(ESMF_Route) :: lroute

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   
        hascachedroute = .FALSE.
        route%this = ESMF_NULL_POINTER

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Translate AxisIndices from F90 to C++
        ! TODO: fix this hack:
        !  The halo code sends in src=dst, so don't decrement
        !  twice in that case.  The AI arrays should really have
        !  an explicit flag saying which indexing scheme they
        !  are currently in, so we can just say "go to fortran order"
        !  or "go to C order" and if already there don't increment 
        !  or decrement too many times.
        do j=1,rank
          do i=1,AI_dst_count
            AI_dst_exc(i,j)%min = AI_dst_exc(i,j)%min - 1
            AI_dst_exc(i,j)%max = AI_dst_exc(i,j)%max - 1
            AI_dst_tot(i,j)%min = AI_dst_tot(i,j)%min - 1
            AI_dst_tot(i,j)%max = AI_dst_tot(i,j)%max - 1
          enddo
          if (.not. associated(AI_src_exc, AI_dst_exc)) then
            do i=1,AI_src_count
              AI_src_exc(i,j)%min = AI_src_exc(i,j)%min - 1
              AI_src_exc(i,j)%max = AI_src_exc(i,j)%max - 1
            enddo
          endif
          if (.not. associated(AI_src_tot, AI_dst_tot)) then
            do i=1,AI_src_count
              AI_src_tot(i,j)%min = AI_src_tot(i,j)%min - 1
              AI_src_tot(i,j)%max = AI_src_tot(i,j)%max - 1
            enddo
          endif
        enddo

        ! Call C++  code
        call c_ESMC_RouteGetCached(rank, &
               my_DE_dst, AI_dst_exc, AI_dst_tot, AI_dst_count, dstDElayout, &
               my_DE_src, AI_src_exc, AI_src_tot, AI_src_count, srcDElayout, &
               periodic, lcache, lroute, status)

        ! Translate AxisIndices back to  F90 from C++
        do j=1,rank
          do i=1,AI_dst_count
            AI_dst_exc(i,j)%min = AI_dst_exc(i,j)%min + 1
            AI_dst_exc(i,j)%max = AI_dst_exc(i,j)%max + 1
            AI_dst_tot(i,j)%min = AI_dst_tot(i,j)%min + 1
            AI_dst_tot(i,j)%max = AI_dst_tot(i,j)%max + 1
          enddo
          if (.not. associated(AI_src_exc, AI_dst_exc)) then
            do i=1,AI_src_count
              AI_src_exc(i,j)%min = AI_src_exc(i,j)%min + 1
              AI_src_exc(i,j)%max = AI_src_exc(i,j)%max + 1
            enddo
          endif
          if (.not. associated(AI_src_tot, AI_dst_tot)) then
            do i=1,AI_src_count
              AI_src_tot(i,j)%min = AI_src_tot(i,j)%min + 1
              AI_src_tot(i,j)%max = AI_src_tot(i,j)%max + 1
            enddo
          endif
        enddo

        if (status .ne. ESMF_SUCCESS) then  
          !print *, "Route Get Cached error"
            hascachedroute = .false.
            if (rcpresent) rc = ESMF_FAILURE
          return  
        endif


        ! Set return values
        if (lcache .eq. ESMF_TRUE) then
            hascachedroute = .true.
            route = lroute
        endif

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteGetCached

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteGetRecvItems"
!BOPI
! !IROUTINE: ESMF_RouteGetRecvItems - Get size of receive buffer

! !INTERFACE:
      subroutine ESMF_RouteGetRecvItems(route, nitems, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(out) :: nitems
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Get the required size of the receive buffer for an {\tt ESMF\_Route} in
!     number of items (not in bytes).  In general a receive buffer is
!     already allocated, but if not, the caller can first query the route
!     for the size of the receive buffer, allocate it, and then call
!     {\tt RouteRun} to move the data.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be modified.
!     \item[nitems]
!          Size of the receive buffer for this route, in number of items.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteGetRecvItems(route, nitems, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteGetRecvItems

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RoutePrecomputeDomList"
!BOPI
! !IROUTINE: ESMF_RoutePrecomputeDomList - Precompute communication paths

! !INTERFACE:
      subroutine ESMF_RoutePrecomputeDomList(route, rank, &
                                             srcDELayout, dstDELayout, &
                                             srcDomainList, dstDomainList, &
                                             hasSrcData, hasDstData, rc)

! !ARGUMENTS:
      type(ESMF_Route),      intent(in   ) :: route
      integer,               intent(in   ) :: rank
      type(ESMF_DELayout),   intent(in   ) :: srcDELayout
      type(ESMF_DELayout),   intent(in   ) :: dstDELayout
      type(ESMF_DomainList), intent(inout) :: srcDomainList
      type(ESMF_DomainList), intent(inout) :: dstDomainList
      logical,               intent(in   ), optional :: hasSrcData
      logical,               intent(in   ), optional :: hasDstData
      integer,               intent(  out), optional :: rc

!
! !DESCRIPTION:
!     Precompute the data movement needed internally by the regrid operation
!     to move the weight information for data interpolation, and store this
!     information in an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route]
!          {\tt ESMF\_Route} to associate this information with.
!     \item[rank]
!          Data rank.
!     \item[srcDELayout]
!          The {\tt ESMF\_DELayout} of the source grid.
!     \item[dstDELayout]
!          The {\tt ESMF\_DELayout} of the destination grid.
!     \item[srcDomainList]
!          An {\tt ESMF\_DomainList} which contains a list of rectangular
!          regions of a larger rectangular block of memory, to be sent
!          during the execution of this route.
!     \item[dstDomainList]
!          An {\tt ESMF\_DomainList} which contains a list of rectangular
!          regions of a larger rectangular block of memory, to be received
!          during the execution of this route.
!     \item[{[hasSrcData]}]
!          Logical which should be false if this DE contains no source data.
!          The default is to assume the current DE contains source data.
!     \item[{[hasDstData]}]
!          Logical which should be false if this DE contains no destination data.
!          The default is to assume the current DE contains destination data.
!     \item[{[rc]}]
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

      ! local variables
      integer :: localrc                 ! local error status
      integer :: i, j                    ! counters
      logical :: hasDstDataUse, hasSrcDataUse
      type(ESMF_Logical) :: hasDstDataX, hasSrcDataX

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_FAILURE

      hasDstDataUse = .true.
      hasDstDataX   = ESMF_TRUE
      if (present(hasDstData)) then
        hasDstDataUse = hasDstData
        if (.not.(hasDstData)) hasDstDataX = ESMF_FALSE
      endif
      hasSrcDataUse = .true.
      hasSrcDataX   = ESMF_TRUE
      if (present(hasSrcData)) then
        hasSrcDataUse = hasSrcData
        if (.not.(hasSrcData)) hasSrcDataX = ESMF_FALSE
      endif

      ! Translate AxisIndices from F90 to C++
      if (hasDstDataUse) then
        do i   = 1, dstDomainList%num_domains
          do j = 1, dstDomainList%domains(i)%rank
            dstDomainList%domains(i)%ai(j)%min = &
                           dstDomainList%domains(i)%ai(j)%min - 1
            dstDomainList%domains(i)%ai(j)%max = &
                           dstDomainList%domains(i)%ai(j)%max - 1
          enddo
        enddo
      endif

      if (hasSrcDataUse) then
        do i   = 1, srcDomainList%num_domains
          do j = 1, srcDomainList%domains(i)%rank
            srcDomainList%domains(i)%ai(j)%min = &
                           srcDomainList%domains(i)%ai(j)%min - 1
            srcDomainList%domains(i)%ai(j)%max = &
                           srcDomainList%domains(i)%ai(j)%max - 1
          enddo
        enddo
      endif

      ! Call C++  code
      call c_ESMC_RoutePrecomputeDomList(route, rank, &
                                         srcDELayout, dstDELayout, &
                                         srcDomainList, dstDomainList, &
                                         hasSrcDataX, hasDstDataX, localrc)
      if (localrc .ne. ESMF_SUCCESS) then
        print *, "Route PrecomputeDomainList error"
        ! don't return before adding 1 back to AIs
      endif

      ! Translate AxisIndices back to F90 from C++
      if (hasDstDataUse) then
        do i   = 1, dstDomainList%num_domains
          do j = 1, dstDomainList%domains(i)%rank
            dstDomainList%domains(i)%ai(j)%min = &
                           dstDomainList%domains(i)%ai(j)%min + 1
            dstDomainList%domains(i)%ai(j)%max = &
                           dstDomainList%domains(i)%ai(j)%max + 1
          enddo
        enddo
      endif

      if (hasSrcDataUse) then
        do i   = 1, srcDomainList%num_domains
          do j = 1, srcDomainList%domains(i)%rank
            srcDomainList%domains(i)%ai(j)%min = &
                           srcDomainList%domains(i)%ai(j)%min + 1
            srcDomainList%domains(i)%ai(j)%max = &
                           srcDomainList%domains(i)%ai(j)%max + 1
          enddo
        enddo
      endif

      if (present(rc)) rc = localrc

        end subroutine ESMF_RoutePrecomputeDomList

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RoutePrecomputeHalo"
!BOPI
! !IROUTINE: ESMF_RoutePrecomputeHalo - Precompute communication paths for a halo

! !INTERFACE:
      subroutine ESMF_RoutePrecomputeHalo(route, rank, my_DE, AI_exc, AI_tot, &
                                          AI_count, global_start, global_count, &
                                          delayout, periodic, rc)

! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(in) :: rank
      integer, intent(in) :: my_DE
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_exc
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_tot
      integer, intent(in) :: AI_count
      integer, dimension(:,:), intent(in) :: global_start
      integer, dimension(ESMF_MAXGRIDDIM), intent(in) :: global_count
      type(ESMF_DELayout), intent(in) :: delayout
      type(ESMF_Logical), intent(in) :: periodic(:)
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Precompute the data movement needed to execute a halo
!     operation, and store this information in an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to associate this information with.
!     \item[rank]
!          Data rank.
!     \item[my_DE]
!          The ID of the local DE.
!     \item[AI_exc]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          exclusive region of the data for each DE.
!          (Note: is this actually the computational region?)
!     \item[AI_tot]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data for each DE.
!     \item[AI_count]
!          Integer number of DEs involved.
!     \item[global_start]
!          Array of integer offsets for the corner of each DE relative
!          to the undecomposed object.
!     \item[global_count]
!          Array of integers, one per dimension, for the total count
!          of items for the undecomposed object.
!     \item[DELayout]
!          {\tt ESMF\_DELayout} for this data decomposition.
!     \item[periodic]
!          An array of {\tt ESMF\_Logical} flags indicating whether the 
!          boundaries in each dimension are to be treated as periodic or not.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI
! !REQUIREMENTS: 

        ! local variables
        integer :: status                  ! local error status
        integer :: i,j                     ! counters
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Translate AxisIndices from F90 to C++
        do j=1,rank
          do i=1,AI_count
            AI_exc(i,j)%min = AI_exc(i,j)%min - 1
            AI_exc(i,j)%max = AI_exc(i,j)%max - 1
            AI_tot(i,j)%min = AI_tot(i,j)%min - 1
            AI_tot(i,j)%max = AI_tot(i,j)%max - 1
          enddo
        enddo

        ! Call C++  code
        call c_ESMC_RoutePrecomputeHalo(route, rank, my_DE, AI_exc, AI_tot, &
                                        AI_count, global_start, global_count, &
                                        delayout, periodic, status)
        if (status .ne. ESMF_SUCCESS) then  
          print *, "Route Precompute Halo error"
          ! don't return before adding 1 back to AIs
        endif

        ! Translate AxisIndices back to  F90 from C++
        do j=1,rank
          do i=1,AI_count
            AI_exc(i,j)%min = AI_exc(i,j)%min + 1
            AI_exc(i,j)%max = AI_exc(i,j)%max + 1
            AI_tot(i,j)%min = AI_tot(i,j)%min + 1
            AI_tot(i,j)%max = AI_tot(i,j)%max + 1
          enddo
        enddo

        if (rcpresent) rc = status

        end subroutine ESMF_RoutePrecomputeHalo

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_RoutePrecomputeRedist - Precompute communication paths

! !INTERFACE:
      subroutine ESMF_RoutePrecomputeRedist(route, rank, dstMyDE, dstCompAI, &
                                            dstTotalAI, dstGlobalStart, &
                                            dstGlobalCount, dstDElayout, &
                                            srcMyDE, srcCompAI, &
                                            srcTotalAI, srcGlobalStart, &
                                            srcGlobalCount, srcDElayout, rc)

! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(in) :: rank
      integer, intent(in) :: dstMyDE
      type(ESMF_AxisIndex), dimension(:,:), pointer :: dstCompAI
      type(ESMF_AxisIndex), dimension(:,:), pointer :: dstTotalAI
      integer, dimension(:,:), intent(in) :: dstGlobalStart
      integer, dimension(ESMF_MAXGRIDDIM), intent(in) :: dstGlobalCount
      type(ESMF_DELayout), intent(in) :: dstDElayout
      integer, intent(in) :: srcMyDE
      type(ESMF_AxisIndex), dimension(:,:), pointer :: srcCompAI
      type(ESMF_AxisIndex), dimension(:,:), pointer :: srcTotalAI
      integer, dimension(:,:), intent(in) :: srcGlobalStart
      integer, dimension(ESMF_MAXGRIDDIM), intent(in) :: srcGlobalCount
      type(ESMF_DELayout), intent(in) :: srcDElayout
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Precompute the data movement needed to execute a 
!     data redistribution operation, and store this 
!     information in an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to associate this information with.
!     \item[rank]
!          Data rank.
!     \item[dstMyDE]
!          The ID of the destination DE.
!     \item[dstCompAI]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          computational region of the data for each DE in the destination.
!     \item[dstTotalAI]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data for each DE in the destination.
!     \item[dstGlobalStart]
!          Array of integer offsets for the corner of each DE relative to
!          the undecomposed destination object.
!     \item[dstGlobalCount]
!          Array of integers, one per dimension, for the total count
!          of items for the undecomposed destination object.
!     \item[dstDELayout]
!          {\tt ESMF\_DELayout} for the destination data decomposition.
!     \item[srcMyDE]
!          The ID of the source DE.
!     \item[srcCompAI]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          computational region of the data for each DE in the source.
!     \item[srcTotalAI]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data for each DE in the source.
!     \item[srcGlobalStart]
!          Array of integer offsets for the corner of each DE relative to
!          the undecomposed source object.
!     \item[srcGlobalCount]
!          Array of integers, one per dimension, for the total count
!          of items for the undecomposed source object.
!     \item[srcDELayout]
!          {\tt ESMF\_DELayout} for the source data decomposition.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?
        integer :: i,j                     ! counters
        integer :: dstAICount, srcAICount

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! set some sizes to pass to C++ code
        dstAICount = size(dstCompAI,1)
        srcAICount = size(srcCompAI,1)

        ! Translate AxisIndices from F90 to C++
        do j   = 1,rank
          do i = 1,dstAICount
            dstCompAI(i,j)%min  =  dstCompAI(i,j)%min - 1
            dstCompAI(i,j)%max  =  dstCompAI(i,j)%max - 1
            dstTotalAI(i,j)%min = dstTotalAI(i,j)%min - 1
            dstTotalAI(i,j)%max = dstTotalAI(i,j)%max - 1
          enddo
          do i = 1,srcAICount
            srcCompAI(i,j)%min  =  srcCompAI(i,j)%min - 1
            srcCompAI(i,j)%max  =  srcCompAI(i,j)%max - 1
            srcTotalAI(i,j)%min = srcTotalAI(i,j)%min - 1
            srcTotalAI(i,j)%max = srcTotalAI(i,j)%max - 1
          enddo
        enddo

        ! Call C++  code
        call c_ESMC_RoutePrecomputeRedist(route, rank, &
                                          dstMyDE, dstCompAI, dstTotalAI, &
                                          dstAICount, dstGlobalStart, &
                                          dstGlobalCount, dstDElayout, &
                                          srcMyDE, srcCompAI, srcTotalAI, &
                                          srcAICount, srcGlobalStart, &
                                          srcGlobalCount, srcDElayout, status)
        if (status .ne. ESMF_SUCCESS) then  
          print *, "Route PrecomputeRedist error"
          ! don't return before adding 1 back to AIs
        endif

        ! Translate AxisIndices back to  F90 from C++
        do j   = 1,rank
          do i = 1,dstAICount
            dstCompAI(i,j)%min  =  dstCompAI(i,j)%min + 1
            dstCompAI(i,j)%max  =  dstCompAI(i,j)%max + 1
            dstTotalAI(i,j)%min = dstTotalAI(i,j)%min + 1
            dstTotalAI(i,j)%max = dstTotalAI(i,j)%max + 1
          enddo
          do i = 1,srcAICount
            srcCompAI(i,j)%min  =  srcCompAI(i,j)%min + 1
            srcCompAI(i,j)%max  =  srcCompAI(i,j)%max + 1
            srcTotalAI(i,j)%min = srcTotalAI(i,j)%min + 1
            srcTotalAI(i,j)%max = srcTotalAI(i,j)%max + 1
          enddo
        enddo

        if (rcpresent) rc = status

        end subroutine ESMF_RoutePrecomputeRedist

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_RoutePrecomputeRegrid - Precompute communication paths

! !INTERFACE:
      subroutine ESMF_RoutePrecomputeRegrid(route, rank, &
               my_DE_dst, AI_dst_exc, AI_dst_tot, AI_dst_count, &
               dst_global_start, dst_global_count, dstDElayout, &
               my_DE_src, AI_src_exc, AI_src_tot, AI_src_count, &
               src_global_start, src_global_count, srcDElayout, rc)


! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(in) :: rank
      integer, intent(in) :: my_DE_dst
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_dst_exc
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_dst_tot
      integer, intent(in) :: AI_dst_count
      integer, dimension(:,:), intent(in) :: dst_global_start
      integer, dimension(ESMF_MAXGRIDDIM), intent(in) :: dst_global_count
      type(ESMF_DELayout), intent(in) :: dstDElayout
      integer, intent(in) :: my_DE_src
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_src_exc
      type(ESMF_AxisIndex), dimension(:,:), pointer :: AI_src_tot
      integer, intent(in) :: AI_src_count
      integer, dimension(:,:), intent(in) :: src_global_start
      integer, dimension(ESMF_MAXGRIDDIM), intent(in) :: src_global_count
      type(ESMF_DELayout), intent(in) :: srcDElayout
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!     Precompute the data movement needed to execute a 
!     data regrid operation, and store this 
!     information in an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to associate this information with.
!     \item[rank]
!          Data rank.
!     \item[my_DE_dst]
!          The ID of the destination DE.
!     \item[AI_dst_exc]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          computational region of the data for each DE in the destination.
!     \item[AI_dst_tot]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data for each DE in the destination.
!     \item[AI_dst_count]
!          Integer count of number of {\tt ESMF\_AxisIndex}s in the
!          destination.
!     \item[dst_global_start]
!          Array of integer offsets for the corner of each DE relative to
!          the undecomposed destination object.
!     \item[dst_global_count]
!          Array of integers, one per dimension, for the total count
!          of items for the undecomposed destination object.
!     \item[dstDELayout]
!          {\tt ESMF\_DELayout} for the destination data decomposition.
!     \item[my_DE_src]
!          The ID of the source DE.
!     \item[AI_src_exc]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          computational region of the data for each DE in the source.
!     \item[AI_src_tot]
!          A 2D array of {\tt ESMF\_AxisIndex}s, describing the
!          total region of the data for each DE in the source.
!     \item[AI_src_count]
!          Integer count of number of {\tt ESMF\_AxisIndex}s in the
!     \item[src_global_start]
!          Array of integer offsets for the corner of each DE relative to
!          the undecomposed source object.
!     \item[src_global_count]
!          Array of integers, one per dimension, for the total count
!          of items for the undecomposed source object.
!     \item[srcDELayout]
!          {\tt ESMF\_DELayout} for the source data decomposition.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        integer :: i,j                     ! counters
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Translate AxisIndices from F90 to C++
        do j=1,rank
          do i=1,AI_dst_count
            AI_dst_exc(i,j)%min = AI_dst_exc(i,j)%min - 1
            AI_dst_exc(i,j)%max = AI_dst_exc(i,j)%max - 1
            AI_dst_tot(i,j)%min = AI_dst_tot(i,j)%min - 1
            AI_dst_tot(i,j)%max = AI_dst_tot(i,j)%max - 1
          enddo
          do i=1,AI_src_count
            AI_src_exc(i,j)%min = AI_src_exc(i,j)%min - 1
            AI_src_exc(i,j)%max = AI_src_exc(i,j)%max - 1
            AI_src_tot(i,j)%min = AI_src_tot(i,j)%min - 1
            AI_src_tot(i,j)%max = AI_src_tot(i,j)%max - 1
          enddo
        enddo

        ! Call C++  code
        call c_ESMC_RoutePrecomputeRegrid(route, rank, &
           my_DE_dst, AI_dst_exc, AI_dst_tot, AI_dst_count, &
           dst_global_start, dst_global_count, dstDElayout, &
           my_DE_src, AI_src_exc, AI_src_tot, AI_src_count, &
           src_global_start, src_global_count, srcDElayout, status)
        if (status .ne. ESMF_SUCCESS) then  
          print *, "Route PrecomputeRegrid error"
          ! don't return before adding 1 back to AIs
        endif

        ! Translate AxisIndices back to  F90 from C++
        do j=1,rank
          do i=1,AI_dst_count
            AI_dst_exc(i,j)%min = AI_dst_exc(i,j)%min + 1
            AI_dst_exc(i,j)%max = AI_dst_exc(i,j)%max + 1
            AI_dst_tot(i,j)%min = AI_dst_tot(i,j)%min + 1
            AI_dst_tot(i,j)%max = AI_dst_tot(i,j)%max + 1
          enddo
          do i=1,AI_src_count
            AI_src_exc(i,j)%min = AI_src_exc(i,j)%min + 1
            AI_src_exc(i,j)%max = AI_src_exc(i,j)%max + 1
            AI_src_tot(i,j)%min = AI_src_tot(i,j)%min + 1
            AI_src_tot(i,j)%max = AI_src_tot(i,j)%max + 1
          enddo
        enddo

        if (rcpresent) rc = status

        end subroutine ESMF_RoutePrecomputeRegrid

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteSetRecvItems"
!BOPI
! !IROUTINE: ESMF_RouteSetRecvItems - Set size of receive buffer

! !INTERFACE:
      subroutine ESMF_RouteSetRecvItems(route, nitems, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(in) :: nitems
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Set the required size of the receive buffer for an {\tt ESMF\_Route} in
!     number of items (not in bytes).  In general a receive buffer is
!     already allocated, but if not, the caller can first query the route
!     for the size of the receive buffer, allocate it, and then call
!     {\tt ESMF\_RouteRun()} to move the data.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be modified.
!     \item[nitems]
!          Size of the receive buffer for this route, in number of items.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteSetRecvItems(route, nitems, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteSetRecvItems

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteSetRecv"
!BOPI
! !IROUTINE: ESMF_RouteSetRecv - Set receive values in a Route

! !INTERFACE:
      subroutine ESMF_RouteSetRecv(route, srcDE, xp, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer, intent(in) :: srcDE
      type(ESMF_XPacket), intent(in) :: xp
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Set receive information in an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be modified.
!     \item[srcDE]
!          Source DE id.
!     \item[xp]
!          Exchange packet describing the data to be received.  Note that
!          an exchange packet only contains offsets and counts; the base
!          address will be specified at route run time.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteSetRecv(route, srcDE, xp, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteSetRecv

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteSetSend"
!BOPI
! !IROUTINE: ESMF_RouteSetSend - Set send values in a Route

! !INTERFACE:
      subroutine ESMF_RouteSetSend(route, destDE, xp, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(inout) :: route
      integer, intent(in) :: destDE
      type(ESMF_XPacket), intent(in) :: xp
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Set send information in an {\tt ESMF\_Route}.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be modified.
!     \item[destDE]
!          Destination DE id.
!     \item[xp]
!          Exchange packet describing the data to be sent.  Note that
!          an exchange packet only contains offsets and counts; the base
!          address will be specified at route run time.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteSetSend(route, destDE, xp, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteSetSend

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RoutePrint"
!BOPI
! !IROUTINE: ESMF_RoutePrint - Print the contents of a Route

! !INTERFACE:
      subroutine ESMF_RoutePrint(route, options, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route      
      character (len=*), intent(in), optional :: options      
      integer, intent(out), optional :: rc           
!
! !DESCRIPTION:
!      Print information about an {\tt ESMF\_Route}.  
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be printed.
!     \item[{[options]}]
!          Print options that control the type of information and level of 
!          detail.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI
! !REQUIREMENTS:  SSSn.n, GGGn.n

       character (len=6) :: defaultopts      ! default print options
       integer :: status                     ! local error status
       logical :: rcpresent

       ! Initialize return code; assume failure until success is certain       
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.  
         rc = ESMF_FAILURE
       endif

       defaultopts = "brief"

       if(present(options)) then
           call c_ESMC_RoutePrint(route, options, status)   
       else
           call c_ESMC_RoutePrint(route, defaultopts, status)
       endif

       if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS
 
       end subroutine ESMF_RoutePrint

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteRun"
!BOPI
! !IROUTINE: ESMF_RouteRun - Execute the communications the Route represents

! !INTERFACE:
      subroutine ESMF_RouteRun(route, srcarray, dstarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      type(ESMF_LocalArray), intent(in), optional :: srcarray
      type(ESMF_LocalArray), intent(in), optional :: dstarray
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Execute the communications this {\tt ESMF\_Route} represents.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be executed.
!     \item[{[srcarray]}]
!          {\tt ESMF\_LocalArray} containing data to be sent.
!     \item[{[dstarray]}]
!          {\tt ESMF\_LocalArray} containing data to be received.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI
! !REQUIREMENTS: 

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteRunLA(route, srcarray, dstarray, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteRun

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteRunF90PtrI411D"
!BOPI
! !IROUTINE: ESMF_RouteRunF90PtrI411D - Execute the communications the Route represents

! !INTERFACE:
      subroutine ESMF_RouteRunF90PtrI411D(route, srcarray, dstarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer(ESMF_KIND_I4), pointer, optional :: srcarray(:)
      integer(ESMF_KIND_I4), pointer, optional :: dstarray(:)
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Execute the communications this {\tt ESMF\_Route} represents.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be executed.
!     \item[{[srcarray]}]
!          1D, Integer*4 Fortran array containing data to be sent.
!     \item[{[dstarray]}]
!          1D, Integer*4 Fortran array containing data to be received.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteRunNA(route, srcarray, dstarray, ESMF_I4, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteRunF90PtrI411D

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteRunF90PtrI421D"
!BOPI
! !IROUTINE: ESMF_RouteRunF90PtrI421D - Execute the communications the Route represents

! !INTERFACE:
      subroutine ESMF_RouteRunF90PtrI421D(route, srcarray, dstarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      integer(ESMF_KIND_I4), pointer, optional :: srcarray(:,:)
      integer(ESMF_KIND_I4), pointer, optional :: dstarray(:)
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Execute the communications this {\tt ESMF\_Route} represents.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be executed.
!     \item[{[srcarray]}]
!          2D, Integer*4 Fortran array containing data to be sent.
!     \item[{[dstarray]}]
!          1D, Integer*4 Fortran array containing data to be received.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteRunNA(route, srcarray, dstarray, ESMF_I4, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteRunF90PtrI421D

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteRunF90PtrR811D"
!BOPI
! !IROUTINE: ESMF_RouteRunF90PtrR811D - Execute the communications the Route represents

! !INTERFACE:
      subroutine ESMF_RouteRunF90PtrR811D(route, srcarray, dstarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      real(ESMF_KIND_R8), pointer, optional :: srcarray(:)
      real(ESMF_KIND_R8), pointer, optional :: dstarray(:)
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Execute the communications this {\tt ESMF\_Route} represents.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be executed.
!     \item[{[srcarray]}]
!          1D, Real*8 Fortran array containing data to be sent.
!     \item[{[dstarray]}]
!          1D, Real*8 Fortran array containing data to be received.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteRunNA(route, srcarray, dstarray, ESMF_R8, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteRunF90PtrR811D

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteRunF90PtrR821D"
!BOPI
! !IROUTINE: ESMF_RouteRunF90PtrR821D - Execute the communications the Route represents

! !INTERFACE:
      subroutine ESMF_RouteRunF90PtrR821D(route, srcarray, dstarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      real(ESMF_KIND_R8), pointer, optional :: srcarray(:,:)
      real(ESMF_KIND_R8), pointer, optional :: dstarray(:)
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Execute the communications this {\tt ESMF\_Route} represents.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be executed.
!     \item[{[srcarray]}]
!          2D, Real*8 Fortran array containing data to be sent.
!     \item[{[dstarray]}]
!          1D, Real*8 Fortran array containing data to be received.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteRunNA(route, srcarray, dstarray, ESMF_R8, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteRunF90PtrR821D

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteRunF90PtrR832D"
!BOPI
! !IROUTINE: ESMF_RouteRunF90PtrR832D - Execute the communications the Route represents
!
! !INTERFACE:
      subroutine ESMF_RouteRunF90PtrR832D(route, srcarray, dstarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route
      real(ESMF_KIND_R8), pointer, optional :: srcarray(:,:,:)
      real(ESMF_KIND_R8), pointer, optional :: dstarray(:,:)
      integer, intent(out), optional :: rc            

!
! !DESCRIPTION:
!     Execute the communications this {\tt ESMF\_Route} represents.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be executed.
!     \item[{[srcarray]}]
!          3D, Real*8 Fortran array containing data to be sent.
!     \item[{[dstarray]}]
!          2D, Real*8 Fortran array containing data to be received.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

        ! local variables
        integer :: status                  ! local error status
        logical :: rcpresent               ! did user specify rc?

        ! Set initial values
        status = ESMF_FAILURE
        rcpresent = .FALSE.   

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Call C++  code
        call c_ESMC_RouteRunNA(route, srcarray, dstarray, ESMF_R8, status)
        if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_RouteRunF90PtrR832D

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_RouteValidate"
!BOPI
! !IROUTINE: ESMF_RouteValidate - Check internal consistency of a Route

! !INTERFACE:
      subroutine ESMF_RouteValidate(route, options, rc)
!
! !ARGUMENTS:
      type(ESMF_Route), intent(in) :: route       
      character (len=*), intent(in), optional :: options    
      integer, intent(out), optional :: rc            
!
! !DESCRIPTION:
!     Validates that a {\tt ESMF\_Route} is internally consistent.
!
!     The arguments are:
!     \begin{description}
!     \item[route] 
!          {\tt ESMF\_Route} to be verified.
!     \item[{[options]}]
!          Validation options.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

       character (len=6) :: defaultopts      ! default validate options
       integer :: status                     ! local error status
       logical :: rcpresent

       ! Initialize return code; assume failure until success is certain       
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.  
         rc = ESMF_FAILURE
       endif

       defaultopts = "quick"

       if(present(options)) then
           call c_ESMC_RouteValidate(route, options, status)   
       else
           call c_ESMC_RouteValidate(route, defaultopts, status)
       endif

       if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_RouteValidate

!------------------------------------------------------------------------------

       end module ESMF_RouteMod
