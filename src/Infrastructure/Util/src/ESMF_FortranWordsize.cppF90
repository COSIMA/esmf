! $Id: ESMF_FortranWordsize.cppF90,v 1.1.2.4 2008/05/02 05:54:12 theurich Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2008, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FortranWordsize.F90"

! ESMF FortranWordsize module
module ESMF_FortranWordsizeMod

!==============================================================================
!
! This file contains wordsize functions that are automatically
!  generated from macros to handle the type/kind overloading.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
! define various macros. >
#include "ESMF_TypeKindMacros.hcppF90"
^include "ESMF.h"
!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod      
  use ESMF_LogErrMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! !PUBLIC FUNCTION:

  public ESMF_FortranUDTPointerSize
  public ESMF_FortranWordsize

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_FortranWordsize -- Generic interface to find Fortran data sizes
!
! !INTERFACE:

  interface ESMF_FortranWordsize

    TypeKindInterfaceMacro(ESMF_FortranWordsize)

!EOPI
  end interface

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FortranUDTPointerSize()"
!BOPI
! !IROUTINE: ESMF_FortranUDTPointerSize - Get size of Fortran 

! !INTERFACE:
  subroutine ESMF_FortranUDTPointerSize(size)
!
! !ARGUMENTS:
    integer, intent(out)  :: size
!EOPI
!------------------------------------------------------------------------------
    integer, parameter :: int8_k = selected_int_kind (12)   ! 8-byte integer
    integer, parameter :: chars_l = 256
    type simple_udt
      sequence
      real :: a, b, c
      integer :: i, j, k
    end type
    integer(int8_k) :: udt_begin
    type(simple_udt), pointer :: udt_ptr
    character :: udt_chars(chars_l), udt_endchar
    equivalence (udt_begin, udt_chars)
    common /udtcom/ udt_begin, udt_ptr, udt_endchar
    
    udt_chars = achar (0)
    udt_endchar = achar (1)
    size = maxloc (iachar (udt_chars), dim=1) - 9

  end subroutine ESMF_FortranUDTPointerSize
!------------------------------------------------------------------------------



!==============================================================================
#define ESMF_FortranWordsizeDoc() \
!BOP @\
! !IROUTINE: ESMF_FortranWordsize - Return the size in byte units of a scalar @\
! @\
! !INTERFACE: @\
!   ! Private name; call using ESMF_FortranWordsize() @\
!   function ESMF_FortranWordsize<typekind>(var, rc) @\
! @\
! !RETURN VALUE: @\
!      integer :: ESMF_FortranWordsize<typekind> @\
! @\
! !ARGUMENTS: @\
!     <type>(ESMF_KIND_<typekind>), intent(in) :: var @\
!     integer, intent(out), optional :: rc @\
! @\
! !DESCRIPTION: @\
!   Return the size in units of bytes of a scalar (var) argument. @\
!   Valid types and kinds supported by the framework are: @\
!   integers of 1-byte, 2-byte, 4-byte, and 8-byte size, and @\
!   reals of 4-byte and 8-bytes size.  @\
! @\
!   The arguments are: @\
!   \begin{description} @\
!   \item [var] @\
!      Scalar of any supported type and kind @\
!   \item [rc] @\
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!   \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define ESMF_FortranWordsizeMacro(mtypename, mtypekind) \
!------------------------------------------------------------------------------ @\
! <Created by macro - do not edit directly > @\
!------------------------------------------------------------------------------ @\
@\
^undef  ESMF_METHOD @\
!define ESMF_METHOD to "ESMF_FortranWordsize##mtypekind" @\
^define ESMF_METHOD "ESMF_FortranWordsize" @\
    integer function ESMF_FortranWordsize##mtypekind(var, rc) @\
@\
     mtypename(ESMF_KIND_##mtypekind), intent(in) :: var @\
     integer, intent(out), optional :: rc @\
@\
     ! local data @\
     integer :: size @\
     mtypename(ESMF_KIND_##mtypekind) :: varTK(2) ! varTK is same TK as var @\
     logical :: rcpresent                    ! Return code present @\
@\
     ! Initialize return code; assume routine not implemented @\
     rcpresent = .FALSE. @\
     if (present(rc)) then @\
         rcpresent = .TRUE. @\
         rc = ESMF_RC_NOT_IMPL @\
     endif @\
@\
     call ESMF_PointerDifference(ESMC_POINTER_SIZE, varTK(1), varTK(2), size) @\
     ESMF_FortranWordsize##mtypekind = size @\
@\
     if (rcpresent) rc = ESMF_SUCCESS @\
@\
     end function ESMF_FortranWordsize##mtypekind @\
@\
! < end macro - do not edit directly >  @\
!---------------------------------------------------------------------------- @\

TypeKindDeclarationMacro(ESMF_FortranWordsize)

!------------------------------------------------------------------------------

end module ESMF_FortranWordsizeMod


subroutine f_esmf_fortranudtpointersize(size)
  use ESMF_FortranWordsizeMod
  integer::size
  call ESMF_FortranUDTPointerSize(size)
end subroutine
